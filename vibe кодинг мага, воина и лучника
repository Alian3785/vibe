# ============================================================
# –ë–õ–û–ö 1: –ö–ê–°–¢–û–ú–ù–ê–Ø –°–†–ï–î–ê Gymnasium ¬´RED vs BLUE¬ª
# ------------------------------------------------------------
# –¢–∏–ø—ã:
#  ‚Ä¢ Archer ‚Äî –æ–¥–∏–Ω–æ—á–Ω–∞—è –∞—Ç–∞–∫–∞
#  ‚Ä¢ –º–∞–≥ ‚Äî –º–∞—Å—Å–æ–≤–∞—è –∞—Ç–∞–∫–∞ –ø–æ –≤—Å–µ–º –∂–∏–≤—ã–º –≤—Ä–∞–≥–∞–º (—É—Ä–æ–Ω 10)
#  ‚Ä¢ –í–æ–∏–Ω ‚Äî –±–ª–∏–∂–Ω–∏–π –±–æ–π —Å–æ —Å–º–µ–∂–Ω–æ—Å—Ç—å—é (—É—Ä–æ–Ω 30, —Å–º. –ø—Ä–∞–≤–∏–ª–∞)
# ------------------------------------------------------------
# –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —è—á–µ–π–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç Stable-Baselines3 –∏ Weights & Biases.
# ============================================================

# (–ö–æ–ª–∞–±) –ú—è–≥–∫–æ —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ Gymnasium —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.
try:
    import gymnasium as gym
except Exception:
    !pip -q install gymnasium
    import gymnasium as gym

import random
from operator import itemgetter
from typing import List, Dict, Optional

import numpy as np
from gymnasium import spaces


# ------------------------ –ò—Å—Ö–æ–¥–Ω—ã–µ —é–Ω–∏—Ç—ã ------------------------
# 12 —é–Ω–∏—Ç–æ–≤: RED (–ø–æ–∑–∏—Ü–∏–∏ 1..6), BLUE (–ø–æ–∑–∏—Ü–∏–∏ 7..12).
# –í –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥–µ: –æ–¥–∏–Ω –º–∞–≥ (Type="–º–∞–≥", –£—Ä–æ–Ω=10, AoE) –∏ –æ–¥–∏–Ω –≤–æ–∏–Ω (Type="–í–æ–∏–Ω", –£—Ä–æ–Ω=30).
# –û—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äî –ª—É—á–Ω–∏–∫–∏ (Type="Archer", –£—Ä–æ–Ω=20). –ó–¥–æ—Ä–æ–≤—å–µ=60. –ò–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞ –∑–∞–¥–∞—ë—Ç –ø–æ—Ä—è–¥–æ–∫ —Ö–æ–¥–æ–≤.
UNITS_RED = [
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å1",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 67, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 67, "team": "red",  "position": 1, "stand": "ahead",  "Type": "–º–∞–≥",    "–£—Ä–æ–Ω": 10, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},  # –º–∞–≥
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å2",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 33, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 33, "team": "red",  "position": 2, "stand": "ahead",  "Type": "–í–æ–∏–Ω",   "–£—Ä–æ–Ω": 30, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},  # –í–æ–∏–Ω
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å3",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 78, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 78, "team": "red",  "position": 3, "stand": "ahead",  "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å7",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 45, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 45, "team": "red",  "position": 4, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å8",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 90, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 90, "team": "red",  "position": 5, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å9",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 12, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 12, "team": "red",  "position": 6, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
]
# –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–æ–∑–º–æ–∂–Ω—É—é –æ–ø–µ—á–∞—Ç–∫—É –∫–ª—é—á–∞ –±–∞–∑–æ–≤–æ–π –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤—ã —É RED
for u in UNITS_RED:
    if "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞" not in u and "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞" in u:
        u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] = u.pop("–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞")

UNITS_BLUE = [
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å4",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 88, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞": 88, "team": "blue", "position": 7,  "stand": "ahead",  "Type": "–º–∞–≥",    "–£—Ä–æ–Ω": 10, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},  # –º–∞–≥
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å5",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 55, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞": 55, "team": "blue", "position": 8,  "stand": "ahead",  "Type": "–í–æ–∏–Ω",   "–£—Ä–æ–Ω": 30, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},  # –í–æ–∏–Ω
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å6",  "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 22, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞": 22, "team": "blue", "position": 9,  "stand": "ahead",  "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å10", "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 60, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞": 60, "team": "blue", "position": 10, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å11", "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 47, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞": 47, "team": "blue", "position": 11, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
    {"–∏–º—è": "—Ä—ã—Ü–∞—Ä—å12", "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞": 75, "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞": 75, "team": "blue", "position": 12, "stand": "behind", "Type": "Archer", "–£—Ä–æ–Ω": 20, "–ó–¥–æ—Ä–æ–≤—å–µ": 60},
]
# –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–æ–∑–º–æ–∂–Ω—É—é –æ–ø–µ—á–∞—Ç–∫—É –∫–ª—é—á–∞ —É BLUE (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
for u in UNITS_BLUE:
    if "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞" not in u and "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞" in u:
        u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] = u.pop("–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞")

# –î–∏–∞–ø–∞–∑–æ–Ω—ã –ø–æ–∑–∏—Ü–∏–π –ø–æ –∫–æ–º–∞–Ω–¥–∞–º
RED_POSITIONS:  List[int] = list(range(1, 7))
BLUE_POSITIONS: List[int] = list(range(7, 13))

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–±–ª—é–¥–µ–Ω–∏–π
MAX_HP   = 60
MAX_INIT = max([u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] for u in (UNITS_RED + UNITS_BLUE)])
MAX_DMG  = max([u["–£—Ä–æ–Ω"] for u in (UNITS_RED + UNITS_BLUE)])


# ------------------------ –ö–∞—Å—Ç–æ–º–Ω–∞—è —Å—Ä–µ–¥–∞ ------------------------
class BattleEnv(gym.Env):
    """
    –°—Ä–µ–¥–∞ RED vs BLUE –¥–ª—è RL.

    –ù–∞–±–ª—é–¥–µ–Ω–∏–µ (obs): –≤–µ–∫—Ç–æ—Ä (120,) = 12 —é–Ω–∏—Ç–æ–≤ √ó 10 –ø—Ä–∏–∑–Ω–∞–∫–æ–≤:
       [HP, INI, INI_base, DMG, team, pos, stand, type_Archer, type_–º–∞–≥, type_–í–æ–∏–Ω] √ó 12.
       –ö–æ–¥–∏—Ä–æ–≤–∫–∏: team red=0/blue=1; stand ahead=0/behind=1; —Ç–∏–ø ‚Äî one-hot (3).
       –ü–æ–ª–µ `–∏–º—è` –Ω–µ –≤–∫–ª—é—á–µ–Ω–æ (—Å—Ç—Ä–æ–∫–æ–≤–æ–µ; –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å –ø–æ–∫—Ä—ã–≤–∞–µ—Ç `pos`).

    –î–µ–π—Å—Ç–≤–∏–µ (action): Discrete(6) ‚Äî –≤—ã–±—Ä–∞—Ç—å —Ü–µ–ª—å —Å—Ä–µ–¥–∏ RED –ø–æ–∑–∏—Ü–∏–π 1..6.

    –¢–∏–ø—ã –∞—Ç–∞–∫–∏:
      ‚Ä¢ Archer ‚Äî –æ–¥–∏–Ω–æ—á–Ω–∞—è –ø–æ —Ü–µ–ª–∏.
      ‚Ä¢ –º–∞–≥ ‚Äî AoE –ø–æ –≤—Å–µ–º –∂–∏–≤—ã–º –≤—Ä–∞–≥–∞–º (—É—Ä–æ–Ω 10).
      ‚Ä¢ –í–æ–∏–Ω ‚Äî –±–ª–∏–∂–Ω–∏–π –±–æ–π —Å–æ —Å–º–µ–∂–Ω–æ—Å—Ç—å—é (—Å–º. –ø—Ä–∞–≤–∏–ª–∞ –≤ –∫–æ–¥–µ).
    """

    metadata = {"render_modes": []}

    def __init__(self, reward_win: float = 1.0, reward_loss: float = -1.0, reward_step: float = 0.0,
                 log_enabled: bool = False):
        super().__init__()
        self.reward_win  = float(reward_win)
        self.reward_loss = float(reward_loss)
        self.reward_step = float(reward_step)

        self.log_enabled = bool(log_enabled)
        self._pretty_events: List[str] = []

        # –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π
        self.action_space = spaces.Discrete(6)

        # –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π: 120 float32
        low_unit  = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float32)
        high_unit = np.array([MAX_HP, MAX_INIT, MAX_INIT, MAX_DMG, 1, 12, 1, 1, 1, 1], dtype=np.float32)
        low  = np.tile(low_unit, 12)
        high = np.tile(high_unit, 12)
        self.observation_space = spaces.Box(low=low, high=high, dtype=np.float32)

        # –°–ª—É–∂–µ–±–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è
        self.rng = random.Random()
        self.combined: List[Dict] = []
        self.round_no: int = 1
        self.winner: Optional[str] = None
        self.current_blue_attacker_pos: Optional[int] = None

    # ------------------ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã ------------------

    def seed(self, seed=None):
        self.rng = random.Random(seed)

    def _alive(self, u) -> bool:
        return u["–ó–¥–æ—Ä–æ–≤—å–µ"] > 0

    def _team_alive(self, team: str) -> bool:
        return any(self._alive(u) and u["team"] == team for u in self.combined)

    def _unit_by_position(self, pos: int):
        return next((u for u in self.combined if u["position"] == pos), None)

    def _live_positions_of(self, team: str):
        return [u["position"] for u in self.combined if u["team"] == team and self._alive(u)]

    def _log(self, s: str):
        if self.log_enabled:
            self._pretty_events.append(s)

    def pop_pretty_events(self) -> List[str]:
        out = self._pretty_events[:]
        self._pretty_events.clear()
        return out

    def _col_of(self, pos: int) -> int:
        """–ö–æ–ª–æ–Ω–∫–∞ 0/1/2 (–ª–µ–≤/—Ü–µ–Ω—Ç—Ä/–ø—Ä–∞–≤) –ø–æ –Ω–æ–º–µ—Ä—É –ø–æ–∑–∏—Ü–∏–∏."""
        return (pos - 1) % 3

    def _enemy_rows(self, team: str):
        """(ahead_positions, behind_positions) –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –≤ –ø–æ—Ä—è–¥–∫–µ –∫–æ–ª–æ–Ω–æ–∫ 0..2."""
        if team == "red":
            return [7, 8, 9], [10, 11, 12]
        else:
            return [1, 2, 3], [4, 5, 6]

    def _warrior_near_far_cols(self, col: int):
        """–ö–∞–∫–∏–µ –∫–æ–ª–æ–Ω–∫–∏ —Å–º–µ–∂–Ω—ã–µ –∏ –¥–∞–ª—å–Ω—è—è –¥–ª—è –≤–æ–∏–Ω–∞ –ø–æ –µ–≥–æ –∫–æ–ª–æ–Ω–∫–µ."""
        if col == 0:   # –ª–µ–≤—ã–π
            return [0, 1], [2]
        if col == 1:   # —Ü–µ–Ω—Ç—Ä
            return [0, 1, 2], []
        return [1, 2], [0]  # –ø—Ä–∞–≤—ã–π

    def _warrior_allowed_targets(self, attacker: Dict) -> List[int]:
        """
        –í–µ—Ä–Ω—É—Ç—å –ø–æ–∑–∏—Ü–∏–∏, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –≤–æ–∏–Ω –ú–û–ñ–ï–¢ —É–¥–∞—Ä–∏—Ç—å —Å–µ–π—á–∞—Å.
        - –í —Ç—ã–ª—É –Ω–µ –∞—Ç–∞–∫—É–µ—Ç, –ø–æ–∫–∞ –∂–∏–≤ –ª—é–±–æ–π —Å–æ—é–∑–Ω—ã–π –≤–æ–∏–Ω –≤–æ —Ñ—Ä–æ–Ω—Ç–µ.
        - –í–æ —Ñ—Ä–æ–Ω—Ç –≤—Ä–∞–≥–∞ —Å–Ω–∞—á–∞–ª–∞ –±—å—ë—Ç —Å–º–µ–∂–Ω—ã—Ö; ¬´–¥–∞–ª—å–Ω–∏–π¬ª –¥–æ—Å—Ç—É–ø–µ–Ω, –∫–æ–≥–¥–∞ –æ–±–∞ —Å–º–µ–∂–Ω—ã—Ö –º–µ—Ä—Ç–≤—ã.
        - –ï—Å–ª–∏ —Ñ—Ä–æ–Ω—Ç –≤—Ä–∞–≥–∞ –≤—ã–±–∏—Ç ‚Äî –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ —Ç—ã–ª—É –≤—Ä–∞–≥–∞.
        """
        assert attacker.get("Type") == "–í–æ–∏–Ω"
        # –ë–ª–æ–∫ –¥–ª—è –≤–æ–∏–Ω–æ–≤ –≤ —Ç—ã–ª—É
        if attacker["stand"] == "behind":
            if any(self._alive(u) and u["team"] == attacker["team"] and u.get("Type") == "–í–æ–∏–Ω" and u["stand"] == "ahead"
                   for u in self.combined):
                return []

        enemy_team = "blue" if attacker["team"] == "red" else "red"
        ahead, behind = self._enemy_rows(attacker["team"])
        col = self._col_of(attacker["position"])
        near_cols, far_cols = self._warrior_near_far_cols(col)

        def alive(pos):
            uu = self._unit_by_position(pos)
            return uu is not None and self._alive(uu)

        # –°–Ω–∞—á–∞–ª–∞ —Ñ—Ä–æ–Ω—Ç
        near = [ahead[c] for c in near_cols if alive(ahead[c])]
        if near:
            return near
        far = [ahead[c] for c in far_cols if alive(ahead[c])]
        if far:
            return far

        # –ï—Å–ª–∏ —Ñ—Ä–æ–Ω—Ç –≤—Ä–∞–≥–∞ –≤—ã–±–∏—Ç ‚Äî —Ç—ã–ª
        near2 = [behind[c] for c in near_cols if alive(behind[c])]
        if near2:
            return near2
        far2 = [behind[c] for c in far_cols if alive(behind[c])]
        return far2

    def _pick_warrior_target_for_red(self, attacker: Dict) -> Optional[int]:
        """RED-–≤–æ–∏–Ω –≤—ã–±–∏—Ä–∞–µ—Ç —Ü–µ–ª—å —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º HP –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö, –ø—Ä–∏ —Ä–∞–≤–µ–Ω—Å—Ç–≤–µ ‚Äî —Å–ª—É—á–∞–π–Ω–∞—è."""
        options = self._warrior_allowed_targets(attacker)
        if not options:
            return None
        pairs = [(self._unit_by_position(p)["–ó–¥–æ—Ä–æ–≤—å–µ"], p) for p in options]
        min_hp = min(h for h, _ in pairs)
        pool = [p for h, p in pairs if h == min_hp]
        return self.rng.choice(pool)

    # ------------------ –ë–æ–µ–≤–∞—è –ª–æ–≥–∏–∫–∞ ------------------

    def _reset_state(self):
        self.combined = [u.copy() for u in (UNITS_RED + UNITS_BLUE)]
        for u in self.combined:
            if "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞" not in u and "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞" in u:
                u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] = u.pop("–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞")
            if "–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞" not in u and "–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞" in u:
                u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] = u.pop("–∏–Ω–∏—Ü–∏–∞—Ç–∏–∏–≤–∞_–±–∞–∑–∞")
            u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"]
        self.round_no = 1
        self.winner = None
        self.current_blue_attacker_pos = None
        self._log(f"–≠–ø–∏–∑–æ–¥ –Ω–∞—á–∞—Ç. –†–∞—É–Ω–¥ {self.round_no}.")

    def _candidates(self):
        return [u for u in self.combined if self._alive(u) and u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] > 0]

    def _pop_next(self):
        cand = self._candidates()
        if not cand:
            return None
        self.rng.shuffle(cand)
        cand.sort(key=itemgetter("–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"), reverse=True)
        return cand[0]

    def _end_round_restore(self):
        for u in self.combined:
            u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"] if self._alive(u) else 0
        self._log("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤—ã. –ù–æ–≤—ã–π —Ä–∞—É–Ω–¥.")

    def _attack(self, attacker, target_pos: Optional[int]):
        """
        –í—ã–ø–æ–ª–Ω–∏—Ç—å —É—Ä–æ–Ω.
          ‚Ä¢ –º–∞–≥ ‚Üí AoE –ø–æ –≤—Å–µ–º –∂–∏–≤—ã–º –≤—Ä–∞–≥–∞–º (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç target_pos).
          ‚Ä¢ Archer/–í–æ–∏–Ω ‚Üí –æ–¥–∏–Ω–æ—á–Ω–∞—è –∞—Ç–∞–∫–∞ –ø–æ target_pos (–µ—Å–ª–∏ —Ü–µ–ª—å –≤–∞–ª–∏–¥–Ω–∞/–∂–∏–≤–∞).
        """
        # AoE –¥–ª—è –º–∞–≥–∞
        if attacker is not None and attacker.get("Type") == "–º–∞–≥":
            enemy_team = "blue" if attacker["team"] == "red" else "red"
            targets = [u for u in self.combined if u["team"] == enemy_team and self._alive(u)]
            if targets:
                self._log(f"{attacker['team'].upper()} {attacker['–∏–º—è']}#{attacker['position']} (–º–∞–≥) –ø—Ä–∏–º–µ–Ω—è–µ—Ç –º–∞—Å—Å–æ–≤—É—é –∞—Ç–∞–∫—É.")
                for victim in targets:
                    before = victim["–ó–¥–æ—Ä–æ–≤—å–µ"]
                    victim["–ó–¥–æ—Ä–æ–≤—å–µ"] -= attacker["–£—Ä–æ–Ω"]
                    after = victim["–ó–¥–æ—Ä–æ–≤—å–µ"]
                    self._log(f"{attacker['team'].upper()} {attacker['–∏–º—è']}#{attacker['position']} ‚Üí "
                              f"{victim['team'].upper()} {victim['–∏–º—è']}#{victim['position']}: {attacker['–£—Ä–æ–Ω']} "
                              f"({before}‚Üí{max(0, after)})")
                    if victim["–ó–¥–æ—Ä–æ–≤—å–µ"] <= 0:
                        victim["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = 0
                        self._log(f"‚úñ {victim['team'].upper()} {victim['–∏–º—è']}#{victim['position']} –≤—ã–≤–µ–¥–µ–Ω –∏–∑ —Å—Ç—Ä–æ—è.")
            else:
                self._log(f"{attacker['team'].upper()} {attacker['–∏–º—è']}#{attacker['position']} (–º–∞–≥) –ø—Ä–∏–º–µ–Ω—è–µ—Ç –º–∞—Å—Å–æ–≤—É—é –∞—Ç–∞–∫—É: —Ü–µ–ª–µ–π –Ω–µ—Ç.")
            return

        # –û–±—ã—á–Ω–∞—è –æ–¥–∏–Ω–æ—á–Ω–∞—è –∞—Ç–∞–∫–∞ (Archer/–í–æ–∏–Ω)
        victim = self._unit_by_position(target_pos) if target_pos is not None else None
        if victim is not None and self._alive(victim):
            before = victim["–ó–¥–æ—Ä–æ–≤—å–µ"]
            victim["–ó–¥–æ—Ä–æ–≤—å–µ"] -= attacker["–£—Ä–æ–Ω"]
            after = victim["–ó–¥–æ—Ä–æ–≤—å–µ"]
            self._log(f"{attacker['team'].upper()} {attacker['–∏–º—è']}#{attacker['position']} ‚Üí "
                      f"{victim['team'].upper()} {victim['–∏–º—è']}#{victim['position']}: {attacker['–£—Ä–æ–Ω']} "
                      f"({before}‚Üí{max(0, after)})")
            if victim["–ó–¥–æ—Ä–æ–≤—å–µ"] <= 0:
                victim["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = 0
                self._log(f"‚úñ {victim['team'].upper()} {victim['–∏–º—è']}#{victim['position']} –≤—ã–≤–µ–¥–µ–Ω –∏–∑ —Å—Ç—Ä–æ—è.")
        else:
            self._log(f"{attacker['team'].upper()} {attacker['–∏–º—è']}#{attacker['position']} –±—å—ë—Ç pos{target_pos}: —Ü–µ–ª–∏ –Ω–µ—Ç/–º–µ—Ä—Ç–≤–∞/–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")

    def _check_victory_after_hit(self):
        if not self._team_alive("blue"):
            self.winner = "red";  self._log("üèÜ –ü–æ–±–µ–¥–∞ RED!")
        elif not self._team_alive("red"):
            self.winner = "blue"; self._log("üèÜ –ü–æ–±–µ–¥–∞ BLUE!")

    def _advance_until_blue_turn(self) -> bool:
        """
        –ê–≤—Ç–æ–ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ö–æ–¥–∞ BLUE –∏–ª–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –±–æ—è.
        RED —Ö–æ–¥–∏—Ç —Å–∞–º: Archer ‚Äî —Å–ª—É—á–∞–π–Ω–æ; –º–∞–≥ ‚Äî AoE; –í–æ–∏–Ω ‚Äî –ø–æ —Å–º–µ–∂–Ω–æ—Å—Ç–∏ –∏ –º–∏–Ω. HP.
        """
        while self._team_alive("red") and self._team_alive("blue"):
            nxt = self._pop_next()
            if nxt is None:
                self._log(f"‚Äî –ö–æ–Ω–µ—Ü —Ä–∞—É–Ω–¥–∞ {self.round_no}.")
                self._end_round_restore()
                self.round_no += 1
                self._log(f"‚Äî –ù–∞—á–∞–ª–æ —Ä–∞—É–Ω–¥–∞ {self.round_no}.")
                continue

            if nxt["team"] == "blue":
                self.current_blue_attacker_pos = nxt["position"]
                self._log(f"–•–æ–¥ BLUE: {nxt['–∏–º—è']}#{nxt['position']} (–∏–Ω–∏—Ü {nxt['–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞']}). –û–∂–∏–¥–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è.")
                return True

            # –•–æ–¥ RED
            nxt["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = 0
            target_pos = None
            if nxt.get("Type") == "–í–æ–∏–Ω":
                target_pos = self._pick_warrior_target_for_red(nxt)
                if target_pos is None:
                    self._log(f"RED —Ö–æ–¥: {nxt['–∏–º—è']}#{nxt['position']} (–í–æ–∏–Ω) –Ω–µ –º–æ–∂–µ—Ç –∞—Ç–∞–∫–æ–≤–∞—Ç—å: –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –Ω–µ—Ç.")
                else:
                    self._log(f"RED —Ö–æ–¥: {nxt['–∏–º—è']}#{nxt['position']} (–í–æ–∏–Ω) ‚Üí –≤—ã–±—Ä–∞–Ω–Ω–∞—è —Ü–µ–ª—å pos{target_pos}.")
            elif nxt.get("Type") == "–º–∞–≥":
                self._log(f"RED —Ö–æ–¥: {nxt['–∏–º—è']}#{nxt['position']} (–º–∞–≥) –≤—ã–ø–æ–ª–Ω—è–µ—Ç –º–∞—Å—Å–æ–≤—É—é –∞—Ç–∞–∫—É.")
            else:
                live_blue_positions = self._live_positions_of("blue")
                target_pos = self.rng.choice(live_blue_positions) if live_blue_positions else None
                self._log(f"RED —Ö–æ–¥: {nxt['–∏–º—è']}#{nxt['position']} ‚Üí —Å–ª—É—á–∞–π–Ω–∞—è —Ü–µ–ª—å pos{target_pos}.")

            if target_pos is not None or nxt.get("Type") == "–º–∞–≥":
                self._attack(nxt, target_pos)
                self._check_victory_after_hit()
                if self.winner is not None:
                    return False
        return False

    # ------------------ –ù–∞–±–ª—é–¥–µ–Ω–∏–µ –¥–ª—è –∞–≥–µ–Ω—Ç–∞ ------------------

    def _obs(self) -> np.ndarray:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ (120,):
          [HP, INI, INI_base, DMG, team(0/1), pos, stand(0/1), Archer, –º–∞–≥, –í–æ–∏–Ω] √ó 12
        """
        vec = []
        type_to_onehot = {
            "Archer": (1.0, 0.0, 0.0),
            "–º–∞–≥":    (0.0, 1.0, 0.0),
            "–í–æ–∏–Ω":   (0.0, 0.0, 1.0),
        }
        for pos in RED_POSITIONS + BLUE_POSITIONS:
            u = self._unit_by_position(pos)
            hp      = float(max(0, u["–ó–¥–æ—Ä–æ–≤—å–µ"]))
            ini     = float(max(0, u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"]))
            ini_b   = float(u["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞_–±–∞–∑–∞"])
            dmg     = float(u["–£—Ä–æ–Ω"])
            team_v  = 0.0 if u["team"] == "red" else 1.0
            pos_v   = float(u["position"])
            stand_v = 0.0 if u["stand"] == "ahead" else 1.0
            oh      = type_to_onehot.get(u.get("Type", "Archer"), (1.0, 0.0, 0.0))
            vec.extend([hp, ini, ini_b, dmg, team_v, pos_v, stand_v, *oh])
        return np.array(vec, dtype=np.float32)

    # ------------------ API Gymnasium ------------------

    def reset(self, *, seed=None, options=None):
        if seed is not None:
            self.seed(seed)
        self._reset_state()
        self._advance_until_blue_turn()
        return self._obs(), {}

    def step(self, action):
        assert self.winner is None, "–≠–ø–∏–∑–æ–¥ –∑–∞–≤–µ—Ä—à—ë–Ω ‚Äî –≤—ã–∑–æ–≤–∏—Ç–µ reset()."

        # –î–æ–∫—Ä—É—Ç–∫–∞ –¥–æ BLUE, –µ—Å–ª–∏ –≤–Ω–µ–∑–∞–ø–Ω–æ –Ω–µ –µ–≥–æ –æ—á–µ—Ä–µ–¥—å
        if self.current_blue_attacker_pos is None:
            self._advance_until_blue_turn()
            if self.winner is not None:
                return self._obs(), (self.reward_win if self.winner == "blue" else self.reward_loss), True, False, {}

        # –•–æ–¥ BLUE
        target_pos = RED_POSITIONS[int(action)]
        attacker = self._unit_by_position(self.current_blue_attacker_pos)
        if attacker is not None and self._alive(attacker) and attacker["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] > 0:
            self._log(f"BLUE –¥–µ–π—Å—Ç–≤–∏–µ: {attacker['–∏–º—è']}#{attacker['position']} ‚Üí pos{target_pos}")
            attacker["–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞"] = 0

            if attacker.get("Type") == "–í–æ–∏–Ω":
                allowed = self._warrior_allowed_targets(attacker)
                if target_pos not in allowed:
                    self._log(f"BLUE {attacker['–∏–º—è']}#{attacker['position']} (–í–æ–∏–Ω) –Ω–µ –º–æ–∂–µ—Ç –¥–æ—Å—Ç–∞—Ç—å pos{target_pos}. "
                              f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {(', '.join('pos'+str(p) for p in allowed)) if allowed else '–Ω–µ—Ç'}")
                else:
                    self._attack(attacker, target_pos)
                    self._check_victory_after_hit()
            else:
                self._attack(attacker, target_pos)
                self._check_victory_after_hit()

        # –ï—Å–ª–∏ –±–æ–π –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è ‚Äî –¥–≤–∏–≥–∞–µ–º —Ö–æ–¥—ã –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ BLUE
        if self.winner is None:
            self.current_blue_attacker_pos = None
            self._advance_until_blue_turn()

        # –ù–∞–≥—Ä–∞–¥–∞ –∏ —Ñ–ª–∞–≥–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        if self.winner is None:
            reward, terminated = self.reward_step, False
        else:
            reward, terminated = (self.reward_win if self.winner == "blue" else self.reward_loss), True

        return self._obs(), reward, terminated, False, {}


# ============================================================
# –ë–õ–û–ö 2: –û–ë–£–ß–ï–ù–ò–ï PPO + W&B, –¢–ï–°–¢ –ò –û–ü–¶–ò–û–ù–ê–õ–¨–ù–ê–Ø –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø
# ------------------------------------------------------------
# –¢—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã –ë–õ–û–ö 1 —É–∂–µ –±—ã–ª –≤—ã–ø–æ–ª–Ω–µ–Ω (–∫–ª–∞—Å—Å BattleEnv –æ–ø—Ä–µ–¥–µ–ª—ë–Ω).
# ============================================================

# (–ö–æ–ª–∞–±) –£—Å—Ç–∞–Ω–æ–≤–∏–º –Ω—É–∂–Ω—ã–µ –ø–∞–∫–µ—Ç—ã: SB3 –∏ W&B. Gymnasium —É–∂–µ —Å—Ç–æ–∏—Ç.
!pip -q install "stable-baselines3[extra]" wandb

import os
import re
import time
import shutil
import random
import numpy as np
import torch

# Stable-Baselines3
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from stable_baselines3.common.callbacks import CallbackList, EvalCallback

# Weights & Biases
import wandb
from wandb.integration.sb3 import WandbCallback


# -------------------- –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—É—á–µ–Ω–∏—è –∏ —Ç–µ—Å—Ç–∞ --------------------
TOTAL_STEPS     = 100000
N_ENVS          = 8
MODEL_SAVE_FREQ = 1_000
EVAL_FREQ       = 1_000
SEED            = 42

VISUALIZE_TEST = True
FRAME_DELAY    = 0.28
USE_COLOR      = True

# -------------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è W&B --------------------
# –ü–µ—Ä–µ–¥ –ø–µ—Ä–≤—ã–º –∑–∞–ø—É—Å–∫–æ–º: wandb.login()
run = wandb.init(
    project="red-blue-battle",
    name=f"ppo-{TOTAL_STEPS//1000}k",
    config={
        "algo": "PPO",
        "total_timesteps": TOTAL_STEPS,
        "n_envs": N_ENVS,
        "n_steps": 1024,
        "batch_size": 2048,
        "gamma": 0.99,
        "gae_lambda": 0.95,
        "learning_rate": 3e-4,
        "clip_range": 0.2,
        "model_save_freq": MODEL_SAVE_FREQ,
        "eval_freq": EVAL_FREQ,
    },
    sync_tensorboard=True,
    save_code=True,
)

# -------------------- –§–∞–±—Ä–∏–∫–∞ —Å—Ä–µ–¥ --------------------
def make_env():
    return Monitor(BattleEnv(reward_win=1.0, reward_loss=-1.0, reward_step=0.0, log_enabled=False))

vec_env  = make_vec_env(make_env, n_envs=N_ENVS, seed=SEED)
eval_env = Monitor(BattleEnv(log_enabled=False))

# -------------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥–µ–ª–∏ PPO --------------------
model = PPO(
    policy="MlpPolicy",
    env=vec_env,
    verbose=1,
    n_steps=1024,
    batch_size=2048,
    gae_lambda=0.95,
    gamma=0.99,
    n_epochs=10,
    learning_rate=3e-4,
    clip_range=0.2,
    ent_coef=0.0,
    vf_coef=0.5,
    seed=SEED,
    tensorboard_log=f"./tb_logs/{run.id}",
)

# -------------------- –ö–æ–ª–±—ç–∫–∏ W&B –∏ –æ—Ü–µ–Ω–∫–∏ --------------------
wandb_cb = WandbCallback(
    gradient_save_freq=1000,
    model_save_path=f"./models/{run.id}",
    model_save_freq=MODEL_SAVE_FREQ,
    verbose=2,
)
eval_cb = EvalCallback(
    eval_env,
    best_model_save_path=f"./models/{run.id}/best",
    log_path=f"./eval/{run.id}",
    eval_freq=EVAL_FREQ,
    n_eval_episodes=5,
    deterministic=True,
    render=False,
)

# -------------------- –û–±—É—á–µ–Ω–∏–µ --------------------
model.learn(total_timesteps=TOTAL_STEPS, callback=CallbackList([wandb_cb, eval_cb]))

# –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—É—é –º–æ–¥–µ–ª—å
model.save("ppo_blue_vs_red")
run.finish()

# -------------------- –¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–æ–≥–æ–Ω —Å –ª–æ–≥–∞–º–∏ --------------------
print("\n=== –¢–ï–°–¢–û–í–´–ô –ü–†–û–ì–û–ù –° –õ–û–ì–ê–ú–ò ===")
test_env = BattleEnv(log_enabled=True)
obs, info = test_env.reset(seed=SEED + 123)

all_logs = []
all_logs += test_env.pop_pretty_events()

done = False
total_reward = 0.0
step_i = 0
while not done:
    step_i += 1
    action, _ = model.predict(obs, deterministic=True)
    target_pos = RED_POSITIONS[int(action)]
    chosen_line = f"[STEP {step_i}] –ê–≥–µ–Ω—Ç –≤—ã–±–∏—Ä–∞–µ—Ç action={int(action)} ‚Üí –∞—Ç–∞–∫–∞ RED pos{target_pos}"
    print("\n" + chosen_line)
    all_logs.append(chosen_line)

    obs, reward, terminated, truncated, info = test_env.step(action)
    total_reward += reward
    done = terminated or truncated

    new_lines = test_env.pop_pretty_events()
    all_logs += new_lines
    for line in new_lines:
        print(line)

print("\n=== –≠–ü–ò–ó–û–î –ó–ê–í–ï–†–®–Å–ù ===")
print("–ü–æ–±–µ–¥–∏—Ç–µ–ª—å:", test_env.winner.upper(), "| –°—É–º–º–∞—Ä–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞:", total_reward)

# -------------------- Matplotlib-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (12 —é–Ω–∏—Ç–æ–≤, 8√ó –º–µ–¥–ª–µ–Ω–Ω–µ–µ, –±–µ–∑ –º–µ—Ä—Ü–∞–Ω–∏—è, –ø–æ–¥—Å–≤–µ—Ç–∫–∏ + –±–∞–Ω–Ω–µ—Ä—ã + —Å—Ç—Ä–µ–ª–∫–∏) --------------------
if VISUALIZE_TEST:
    import matplotlib.pyplot as plt
    from matplotlib import patches
    from IPython.display import display
    import re, time, math

    VISUAL_SPEED_MULT = 8.0  # –±—ã–ª–æ 4√ó, –ø–æ –ø—Ä–æ—Å—å–±–µ –∑–∞–º–µ–¥–ª–∏–ª –µ—â—ë –≤ 2√ó

    RED_FRONT, RED_BACK   = [1,2,3],   [4,5,6]
    BLUE_FRONT, BLUE_BACK = [7,8,9],   [10,11,12]
    COL_X = {0: 0.18, 1: 0.50, 2: 0.82}
    Y_BLUE_BACK, Y_BLUE_FRONT = 0.88, 0.70
    Y_RED_FRONT,  Y_RED_BACK  = 0.30, 0.12
    SLOT_W, SLOT_H = 0.28, 0.13
    HP_H = 0.025

    # —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
    state = {pos: {"team": ("red" if pos in RED_POSITIONS else "blue"),
                   "name": f"pos{pos}", "hp": MAX_HP,
                   "stand": "ahead" if (pos in [1,2,3,7,8,9]) else "behind",
                   "type": "Archer"} for pos in (RED_POSITIONS + BLUE_POSITIONS)}
    for u in (UNITS_RED + UNITS_BLUE):
        suffix = " (–º–∞–≥)" if u.get("Type") == "–º–∞–≥" else (" (–≤–æ–∏–Ω)" if u.get("Type") == "–í–æ–∏–Ω" else "")
        state[u["position"]]["name"]  = u["–∏–º—è"] + suffix
        state[u["position"]]["stand"] = u["stand"]
        state[u["position"]]["type"]  = u.get("Type", "Archer")

    # —Ä–µ–≥–µ–∫—Å—ã
    atk_re   = re.compile(r'^(RED|BLUE)\s+[^\s#]+#(\d+)\s+‚Üí\s+(RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)‚Üí(\d+)\)')
    kill_re  = re.compile(r'^‚úñ\s+(RED|BLUE)\s+[^\s#]+#(\d+)\s+–≤—ã–≤–µ–¥–µ–Ω –∏–∑ —Å—Ç—Ä–æ—è\.')
    vict_re  = re.compile(r'^üèÜ –ü–æ–±–µ–¥–∞ (RED|BLUE)!')
    blue_turn_re    = re.compile(r'^–•–æ–¥ BLUE:\s+[^\s#]+#(\d+)')
    red_turn_re     = re.compile(r'^RED —Ö–æ–¥:\s+[^\s#]+#(\d+)')
    blue_action_re  = re.compile(r'^BLUE –¥–µ–π—Å—Ç–≤–∏–µ:\s+[^\s#]+#(\d+)\s+‚Üí\s+pos(\d+)')
    red_target_re   = re.compile(r'^RED —Ö–æ–¥:\s+[^\s#]+#(\d+).+—Ü–µ–ª—å pos(\d+)')
    mage_banner_re  = re.compile(r'^\w+\s+[^\s#]+#(\d+)\s+\(–º–∞–≥\).+–º–∞—Å—Å–æ–≤')  # AOE –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    blue_cant_re    = re.compile(r'^BLUE\s+[^\s#]+#(\d+).+–Ω–µ –º–æ–∂–µ—Ç –¥–æ—Å—Ç–∞—Ç—å pos(\d+)')

    # —Ñ–∏–≥—É—Ä–∞ (–±–µ–∑ –º–µ—Ä—Ü–∞–Ω–∏—è)
    fig, ax = plt.subplots(figsize=(12, 8))
    plt.close(fig)
    handle = display(fig, display_id=True)

    # -------- —É—Ç–∏–ª–∏—Ç—ã --------
    def pos_to_xy(pos: int):
        col = (pos - 1) % 3
        x = COL_X[col] - SLOT_W/2
        if pos in BLUE_BACK:   y = Y_BLUE_BACK  - SLOT_H/2
        elif pos in BLUE_FRONT:y = Y_BLUE_FRONT - SLOT_H/2
        elif pos in RED_FRONT: y = Y_RED_FRONT  - SLOT_H/2
        else:                  y = Y_RED_BACK   - SLOT_H/2
        return x, y

    def center_of(pos: int):
        x, y = pos_to_xy(pos)
        return (x + SLOT_W/2, y + SLOT_H/2)

    def shrink_segment(x1,y1,x2,y2, shrink=0.06):
        """–°–¥–≤–∏–≥–∞–µ–º –Ω–∞—á–∞–ª–æ/–∫–æ–Ω–µ—Ü –≤–Ω—É—Ç—Ä—å, —á—Ç–æ–±—ã —Å—Ç—Ä–µ–ª–∫–∞ –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–ª–∞ —Ä–∞–º–∫–∏ —Å–ª–æ—Ç–æ–≤."""
        dx, dy = x2-x1, y2-y1
        L = math.hypot(dx, dy) or 1e-6
        ux, uy = dx/L, dy/L
        return (x1 + ux*shrink, y1 + uy*shrink, x2 - ux*shrink, y2 - uy*shrink)

    def _base_name(name: str) -> str:
        for suf in (" (–º–∞–≥)"," (–≤–æ–∏–Ω)"):
            if name.endswith(suf):
                return name[:-len(suf)]
        return name

    def _type_label(t: str) -> str:
        return {"–º–∞–≥": "–º–∞–≥", "–í–æ–∏–Ω": "–í–æ–∏–Ω", "Archer": "–õ—É—á–Ω–∏–∫"}.get(t, t)

    def draw_unit(ax, pos, is_active=False, is_hit=False):
        u = state[pos]; x, y = pos_to_xy(pos)
        base = (0.90, 0.30, 0.30) if u["team"] == "red" else (0.30, 0.45, 0.90)
        ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                            boxstyle="round,pad=0.008,rounding_size=0.015",
                                            linewidth=1.3, edgecolor="black", facecolor=base, alpha=0.18))
        if is_hit:
            ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=2.0, edgecolor=(0.75,0.05,0.05),
                                                facecolor=(1.0,0.0,0.0,0.15)))
        ax.text(x + 0.012, y + SLOT_H*0.72, u["name"][:18],
                fontsize=10, fontweight="bold", ha="left", va="center", color="black")
        t = u.get("type", "Archer"); t_icon = "A" if t=="Archer" else ("M" if t=="–º–∞–≥" else "W")
        ax.text(x + SLOT_W - 0.012, y + SLOT_H*0.72, t_icon,
                fontsize=11, fontweight="bold", ha="right", va="center", color="black")
        hp_x, hp_y = x + 0.012, y + SLOT_H*0.20
        ax.add_patch(patches.Rectangle((hp_x, hp_y), SLOT_W-0.024, HP_H, color=(0.85,0.85,0.85), lw=0))
        frac = max(0.0, min(1.0, u["hp"]/MAX_HP))
        ax.add_patch(patches.Rectangle((hp_x, hp_y), (SLOT_W-0.024)*frac, HP_H, color=(0.10,0.70,0.20), lw=0))
        ax.text(x + SLOT_W/2, hp_y + HP_H*2.2, f"{int(u['hp'])} HP", fontsize=9, ha="center", va="center", color="black")
        ax.text(x + SLOT_W/2, y - 0.008, f"pos{pos}", fontsize=8, ha="center", va="top", color=(0.2,0.2,0.2))
        if is_active:
            ax.add_patch(patches.FancyBboxPatch((x-0.004, y-0.004), SLOT_W+0.008, SLOT_H+0.008,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=3.0, edgecolor=(1.0,0.85,0.10), facecolor=(1,1,0,0.05)))

    def draw_arrows(ax, arrows):
        """arrows: —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π {src:int, dst:int, color, lw, ls, alpha}"""
        for a in arrows or []:
            x1, y1 = center_of(a["src"])
            x2, y2 = center_of(a["dst"])
            x1, y1, x2, y2 = shrink_segment(x1, y1, x2, y2, shrink=0.06)
            ax.annotate("",
                        xy=(x2, y2), xytext=(x1, y1),
                        arrowprops=dict(arrowstyle="->",
                                        lw=a.get("lw", 2.0),
                                        color=a.get("color", (0.9,0.2,0.2)),
                                        linestyle=a.get("ls", "-"),
                                        alpha=a.get("alpha", 0.95)),
                        zorder=5)

    def draw_board(banner:str="", highlight_yellow=None, highlight_red=None, arrows=None):
        hy = set(highlight_yellow or []); hr = set(highlight_red or [])
        ax.cla()
        ax.set_xlim(0, 1); ax.set_ylim(0, 1); ax.axis("off")
        ax.plot([0.02, 0.98], [0.50, 0.50], color=(0.6,0.6,0.6), lw=1.2, ls="--", alpha=0.7)
        ax.text(0.01, 0.96, "BLUE (top)", color=(0.2,0.35,0.8), fontsize=12, fontweight="bold", ha="left")
        ax.text(0.01, 0.04, "RED (bottom)", color=(0.8,0.25,0.25), fontsize=12, fontweight="bold", ha="left")
        for pos in BLUE_BACK + BLUE_FRONT + RED_FRONT + RED_BACK:
            draw_unit(ax, pos, is_active=(pos in hy), is_hit=(pos in hr))
        draw_arrows(ax, arrows)
        if banner:
            ax.text(0.5, 0.52, banner[:120], fontsize=12, ha="center", va="bottom", color=(0.15,0.15,0.15))
        fig.canvas.draw()
        handle.update(fig)

    def attack_banner(atk_pos:int, vic_pos:int) -> str:
        a = state[atk_pos]; v = state[vic_pos]
        return (f'–Æ–Ω–∏—Ç "{_base_name(a["name"])}" —Ç–∏–ø–∞ "{_type_label(a["type"])}" '
                f'—Å –ø–æ–∑–∏—Ü–∏–∏ {atk_pos} –∞—Ç–∞–∫–æ–≤–∞–ª —é–Ω–∏—Ç–∞ "{_base_name(v["name"])}" '
                f'–Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ {vic_pos}')

    def turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'–Æ–Ω–∏—Ç "{_base_name(a["name"])}" —Ç–∏–ø–∞ "{_type_label(a["type"])}" '
                f'—Å –ø–æ–∑–∏—Ü–∏–∏ {atk_pos} –≥–æ—Ç–æ–≤–∏—Ç—Å—è –∫ —Ö–æ–¥—É')

    def action_banner(atk_pos:int, tgt_pos:int) -> str:
        a = state[atk_pos]
        return (f'–Æ–Ω–∏—Ç "{_base_name(a["name"])}" —Ç–∏–ø–∞ "{_type_label(a["type"])}" '
                f'—Å –ø–æ–∑–∏—Ü–∏–∏ {atk_pos} –≥–æ—Ç–æ–≤–∏—Ç—Å—è –∞—Ç–∞–∫–æ–≤–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é {tgt_pos}')

    def mage_turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'–Æ–Ω–∏—Ç "{_base_name(a["name"])}" —Ç–∏–ø–∞ "–º–∞–≥" '
                f'—Å –ø–æ–∑–∏—Ü–∏–∏ {atk_pos} –≥–æ—Ç–æ–≤–∏—Ç—Å—è –ø—Ä–∏–º–µ–Ω–∏—Ç—å –º–∞—Å—Å–æ–≤—É—é –∞—Ç–∞–∫—É')

    # –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä
    draw_board("–ù–∞—á–∞–ª–æ –±–æ—è")

    # —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
    for line in all_logs:
        hy, hr = set(), set()
        arrows = []

        # –£—Ä–æ–Ω (–æ–¥–Ω–∞ —Ü–µ–ª—å) ‚Äî –∫—Ä–∞—Å–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞
        m = atk_re.match(line)
        if m:
            atk_pos = int(m.group(2)); vic_pos = int(m.group(4)); after = int(m.group(7))
            if vic_pos in state: state[vic_pos]["hp"] = after
            hy.add(atk_pos); hr.add(vic_pos)
            arrows.append({"src": atk_pos, "dst": vic_pos, "color": (0.9,0.15,0.15), "lw": 2.6, "ls": "-", "alpha": 0.95})
            draw_board(attack_banner(atk_pos, vic_pos), hy, hr, arrows)
            time.sleep(FRAME_DELAY * VISUAL_SPEED_MULT)
            continue

        # –û–±—ä—è–≤–ª–µ–Ω–∏—è —Ö–æ–¥–∞
        m = blue_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # –ê–≥–µ–Ω—Ç –≤—ã–±—Ä–∞–ª —Ü–µ–ª—å ‚Äî –∂—ë–ª—Ç–∞—è –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞ –∫ –ø–æ–∑–∏—Ü–∏–∏
        m = blue_action_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_target_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # –ú–∞—Å—Å–æ–≤–∞—è –∞—Ç–∞–∫–∞ –º–∞–≥–∞ ‚Äî –ø—É–Ω–∫—Ç–∏—Ä –∫ –∫–∞–∂–¥–æ–º—É –∂–∏–≤–æ–º—É –≤—Ä–∞–≥—É
        m = mage_banner_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            enemy_team = "blue" if state[atk_pos]["team"] == "red" else "red"
            enemy_positions = [p for p,v in state.items() if v["team"] == enemy_team and v["hp"] > 0]
            for ep in enemy_positions:
                arrows.append({"src": atk_pos, "dst": ep, "color": (1.0,0.85,0.10), "lw": 1.6, "ls": "--", "alpha": 0.9})
            draw_board(mage_turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # –¶–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ ‚Äî —Ç–æ–∂–µ –∂—ë–ª—Ç–∞—è –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è
        m = blue_cant_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.8})
            draw_board(action_banner(atk_pos, tgt_pos) + " (—Ü–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞)", hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # –ü—Ä–æ—á–∏–µ —Å—Ç—Ä–æ–∫–∏ (–∫–∏–ª–ª/–ø–æ–±–µ–¥–∞/–≥—Ä–∞–Ω–∏—Ü—ã/STEP)
        if (kill_re.match(line) or vict_re.match(line)
            or line.startswith("‚Äî ") or line.startswith("[STEP")):
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # –§–æ–ª–ª–±–µ–∫
        draw_board(line, hy, hr, arrows)
        time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)

    draw_board("–ö–æ–Ω–µ—Ü —ç–ø–∏–∑–æ–¥–∞")
    time.sleep(0.8 * VISUAL_SPEED_MULT)
