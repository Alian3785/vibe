# ============================================================
# БЛОК 1: КАСТОМНАЯ СРЕДА Gymnasium «RED vs BLUE»
# ------------------------------------------------------------
# Типы:
#  • Archer — одиночная атака
#  • маг — массовая атака по всем живым врагам (урон 10)
#  • Воин — ближний бой со смежностью (урон 30, см. правила)
# ------------------------------------------------------------
# Примечание: ячейка не требует Stable-Baselines3 и Weights & Biases.
# ============================================================

# (Колаб) Мягко убедимся, что Gymnasium установлен.
try:
    import gymnasium as gym
except Exception:
    !pip -q install gymnasium
    import gymnasium as gym

import random
from operator import itemgetter
from typing import List, Dict, Optional

import numpy as np
from gymnasium import spaces


# ------------------------ Исходные юниты ------------------------
# 12 юнитов: RED (позиции 1..6), BLUE (позиции 7..12).
# В каждой команде: один маг (Type="маг", Урон=10, AoE) и один воин (Type="Воин", Урон=30).
# Остальные — лучники (Type="Archer", Урон=20). Здоровье=60. Инициатива задаёт порядок ходов.
UNITS_RED = [
    {"имя": "рыцарь1",  "инициатива": 67, "инициатиива_база": 67, "team": "red",  "position": 1, "stand": "ahead",  "Type": "маг",    "Урон": 10, "Здоровье": 60},  # маг
    {"имя": "рыцарь2",  "инициатива": 33, "инициатиива_база": 33, "team": "red",  "position": 2, "stand": "ahead",  "Type": "Воин",   "Урон": 30, "Здоровье": 60},  # Воин
    {"имя": "рыцарь3",  "инициатива": 78, "инициатиива_база": 78, "team": "red",  "position": 3, "stand": "ahead",  "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь7",  "инициатива": 45, "инициатиива_база": 45, "team": "red",  "position": 4, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь8",  "инициатива": 90, "инициатиива_база": 90, "team": "red",  "position": 5, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь9",  "инициатива": 12, "инициатиива_база": 12, "team": "red",  "position": 6, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
]
# Нормализуем возможную опечатку ключа базовой инициативы у RED
for u in UNITS_RED:
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")

UNITS_BLUE = [
    {"имя": "рыцарь4",  "инициатива": 88, "инициатива_база": 88, "team": "blue", "position": 7,  "stand": "ahead",  "Type": "маг",    "Урон": 10, "Здоровье": 60},  # маг
    {"имя": "рыцарь5",  "инициатива": 55, "инициатива_база": 55, "team": "blue", "position": 8,  "stand": "ahead",  "Type": "Воин",   "Урон": 30, "Здоровье": 60},  # Воин
    {"имя": "рыцарь6",  "инициатива": 22, "инициатива_база": 22, "team": "blue", "position": 9,  "stand": "ahead",  "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь10", "инициатива": 60, "инициатива_база": 60, "team": "blue", "position": 10, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь11", "инициатива": 47, "инициатива_база": 47, "team": "blue", "position": 11, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
    {"имя": "рыцарь12", "инициатива": 75, "инициатиива_база": 75, "team": "blue", "position": 12, "stand": "behind", "Type": "Archer", "Урон": 20, "Здоровье": 60},
]
# Нормализуем возможную опечатку ключа у BLUE (на всякий случай)
for u in UNITS_BLUE:
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")

# Диапазоны позиций по командам
RED_POSITIONS:  List[int] = list(range(1, 7))
BLUE_POSITIONS: List[int] = list(range(7, 13))

# Константы для нормирования наблюдений
MAX_HP   = 60
MAX_INIT = max([u["инициатива_база"] for u in (UNITS_RED + UNITS_BLUE)])
MAX_DMG  = max([u["Урон"] for u in (UNITS_RED + UNITS_BLUE)])


# ------------------------ Кастомная среда ------------------------
class BattleEnv(gym.Env):
    """
    Среда RED vs BLUE для RL.

    Наблюдение (obs): вектор (120,) = 12 юнитов × 10 признаков:
       [HP, INI, INI_base, DMG, team, pos, stand, type_Archer, type_маг, type_Воин] × 12.
       Кодировки: team red=0/blue=1; stand ahead=0/behind=1; тип — one-hot (3).
       Поле `имя` не включено (строковое; идентичность покрывает `pos`).

    Действие (action): Discrete(6) — выбрать цель среди RED позиций 1..6.

    Типы атаки:
      • Archer — одиночная по цели.
      • маг — AoE по всем живым врагам (урон 10).
      • Воин — ближний бой со смежностью (см. правила в коде).
    """

    metadata = {"render_modes": []}

    def __init__(self, reward_win: float = 1.0, reward_loss: float = -1.0, reward_step: float = 0.0,
                 log_enabled: bool = False):
        super().__init__()
        self.reward_win  = float(reward_win)
        self.reward_loss = float(reward_loss)
        self.reward_step = float(reward_step)

        self.log_enabled = bool(log_enabled)
        self._pretty_events: List[str] = []

        # Пространство действий
        self.action_space = spaces.Discrete(6)

        # Пространство наблюдений: 120 float32
        low_unit  = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float32)
        high_unit = np.array([MAX_HP, MAX_INIT, MAX_INIT, MAX_DMG, 1, 12, 1, 1, 1, 1], dtype=np.float32)
        low  = np.tile(low_unit, 12)
        high = np.tile(high_unit, 12)
        self.observation_space = spaces.Box(low=low, high=high, dtype=np.float32)

        # Служебное состояние боя
        self.rng = random.Random()
        self.combined: List[Dict] = []
        self.round_no: int = 1
        self.winner: Optional[str] = None
        self.current_blue_attacker_pos: Optional[int] = None

    # ------------------ Вспомогательные методы ------------------

    def seed(self, seed=None):
        self.rng = random.Random(seed)

    def _alive(self, u) -> bool:
        return u["Здоровье"] > 0

    def _team_alive(self, team: str) -> bool:
        return any(self._alive(u) and u["team"] == team for u in self.combined)

    def _unit_by_position(self, pos: int):
        return next((u for u in self.combined if u["position"] == pos), None)

    def _live_positions_of(self, team: str):
        return [u["position"] for u in self.combined if u["team"] == team and self._alive(u)]

    def _log(self, s: str):
        if self.log_enabled:
            self._pretty_events.append(s)

    def pop_pretty_events(self) -> List[str]:
        out = self._pretty_events[:]
        self._pretty_events.clear()
        return out

    def _col_of(self, pos: int) -> int:
        """Колонка 0/1/2 (лев/центр/прав) по номеру позиции."""
        return (pos - 1) % 3

    def _enemy_rows(self, team: str):
        """(ahead_positions, behind_positions) противника в порядке колонок 0..2."""
        if team == "red":
            return [7, 8, 9], [10, 11, 12]
        else:
            return [1, 2, 3], [4, 5, 6]

    def _warrior_near_far_cols(self, col: int):
        """Какие колонки смежные и дальняя для воина по его колонке."""
        if col == 0:   # левый
            return [0, 1], [2]
        if col == 1:   # центр
            return [0, 1, 2], []
        return [1, 2], [0]  # правый

    def _warrior_allowed_targets(self, attacker: Dict) -> List[int]:
        """
        Вернуть позиции, по которым воин МОЖЕТ ударить сейчас.
        - В тылу не атакует, пока жив любой союзный воин во фронте.
        - Во фронт врага сначала бьёт смежных; «дальний» доступен, когда оба смежных мертвы.
        - Если фронт врага выбит — правила применяются к тылу врага.
        """
        assert attacker.get("Type") == "Воин"
        # Блок для воинов в тылу
        if attacker["stand"] == "behind":
            if any(self._alive(u) and u["team"] == attacker["team"] and u.get("Type") == "Воин" and u["stand"] == "ahead"
                   for u in self.combined):
                return []

        enemy_team = "blue" if attacker["team"] == "red" else "red"
        ahead, behind = self._enemy_rows(attacker["team"])
        col = self._col_of(attacker["position"])
        near_cols, far_cols = self._warrior_near_far_cols(col)

        def alive(pos):
            uu = self._unit_by_position(pos)
            return uu is not None and self._alive(uu)

        # Сначала фронт
        near = [ahead[c] for c in near_cols if alive(ahead[c])]
        if near:
            return near
        far = [ahead[c] for c in far_cols if alive(ahead[c])]
        if far:
            return far

        # Если фронт врага выбит — тыл
        near2 = [behind[c] for c in near_cols if alive(behind[c])]
        if near2:
            return near2
        far2 = [behind[c] for c in far_cols if alive(behind[c])]
        return far2

    def _pick_warrior_target_for_red(self, attacker: Dict) -> Optional[int]:
        """RED-воин выбирает цель с минимальным HP из доступных, при равенстве — случайная."""
        options = self._warrior_allowed_targets(attacker)
        if not options:
            return None
        pairs = [(self._unit_by_position(p)["Здоровье"], p) for p in options]
        min_hp = min(h for h, _ in pairs)
        pool = [p for h, p in pairs if h == min_hp]
        return self.rng.choice(pool)

    # ------------------ Боевая логика ------------------

    def _reset_state(self):
        self.combined = [u.copy() for u in (UNITS_RED + UNITS_BLUE)]
        for u in self.combined:
            if "инициатива_база" not in u and "инициатиива_база" in u:
                u["инициатива_база"] = u.pop("инициатиива_база")
            if "инициатива_база" not in u and "инициатиива_база" in u:
                u["инициатива_база"] = u.pop("инициатиива_база")
            u["инициатива"] = u["инициатива_база"]
        self.round_no = 1
        self.winner = None
        self.current_blue_attacker_pos = None
        self._log(f"Эпизод начат. Раунд {self.round_no}.")

    def _candidates(self):
        return [u for u in self.combined if self._alive(u) and u["инициатива"] > 0]

    def _pop_next(self):
        cand = self._candidates()
        if not cand:
            return None
        self.rng.shuffle(cand)
        cand.sort(key=itemgetter("инициатива"), reverse=True)
        return cand[0]

    def _end_round_restore(self):
        for u in self.combined:
            u["инициатива"] = u["инициатива_база"] if self._alive(u) else 0
        self._log("Восстановление инициативы. Новый раунд.")

    def _attack(self, attacker, target_pos: Optional[int]):
        """
        Выполнить урон.
          • маг → AoE по всем живым врагам (игнорирует target_pos).
          • Archer/Воин → одиночная атака по target_pos (если цель валидна/жива).
        """
        # AoE для мага
        if attacker is not None and attacker.get("Type") == "маг":
            enemy_team = "blue" if attacker["team"] == "red" else "red"
            targets = [u for u in self.combined if u["team"] == enemy_team and self._alive(u)]
            if targets:
                self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} (маг) применяет массовую атаку.")
                for victim in targets:
                    before = victim["Здоровье"]
                    victim["Здоровье"] -= attacker["Урон"]
                    after = victim["Здоровье"]
                    self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} → "
                              f"{victim['team'].upper()} {victim['имя']}#{victim['position']}: {attacker['Урон']} "
                              f"({before}→{max(0, after)})")
                    if victim["Здоровье"] <= 0:
                        victim["инициатива"] = 0
                        self._log(f"✖ {victim['team'].upper()} {victim['имя']}#{victim['position']} выведен из строя.")
            else:
                self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} (маг) применяет массовую атаку: целей нет.")
            return

        # Обычная одиночная атака (Archer/Воин)
        victim = self._unit_by_position(target_pos) if target_pos is not None else None
        if victim is not None and self._alive(victim):
            before = victim["Здоровье"]
            victim["Здоровье"] -= attacker["Урон"]
            after = victim["Здоровье"]
            self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} → "
                      f"{victim['team'].upper()} {victim['имя']}#{victim['position']}: {attacker['Урон']} "
                      f"({before}→{max(0, after)})")
            if victim["Здоровье"] <= 0:
                victim["инициатива"] = 0
                self._log(f"✖ {victim['team'].upper()} {victim['имя']}#{victim['position']} выведен из строя.")
        else:
            self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} бьёт pos{target_pos}: цели нет/мертва/недоступна.")

    def _check_victory_after_hit(self):
        if not self._team_alive("blue"):
            self.winner = "red";  self._log("🏆 Победа RED!")
        elif not self._team_alive("red"):
            self.winner = "blue"; self._log("🏆 Победа BLUE!")

    def _advance_until_blue_turn(self) -> bool:
        """
        Автопрокрутка до следующего хода BLUE или завершения боя.
        RED ходит сам: Archer — случайно; маг — AoE; Воин — по смежности и мин. HP.
        """
        while self._team_alive("red") and self._team_alive("blue"):
            nxt = self._pop_next()
            if nxt is None:
                self._log(f"— Конец раунда {self.round_no}.")
                self._end_round_restore()
                self.round_no += 1
                self._log(f"— Начало раунда {self.round_no}.")
                continue

            if nxt["team"] == "blue":
                self.current_blue_attacker_pos = nxt["position"]
                self._log(f"Ход BLUE: {nxt['имя']}#{nxt['position']} (иниц {nxt['инициатива']}). Ожидание действия.")
                return True

            # Ход RED
            nxt["инициатива"] = 0
            target_pos = None
            if nxt.get("Type") == "Воин":
                target_pos = self._pick_warrior_target_for_red(nxt)
                if target_pos is None:
                    self._log(f"RED ход: {nxt['имя']}#{nxt['position']} (Воин) не может атаковать: доступных целей нет.")
                else:
                    self._log(f"RED ход: {nxt['имя']}#{nxt['position']} (Воин) → выбранная цель pos{target_pos}.")
            elif nxt.get("Type") == "маг":
                self._log(f"RED ход: {nxt['имя']}#{nxt['position']} (маг) выполняет массовую атаку.")
            else:
                live_blue_positions = self._live_positions_of("blue")
                target_pos = self.rng.choice(live_blue_positions) if live_blue_positions else None
                self._log(f"RED ход: {nxt['имя']}#{nxt['position']} → случайная цель pos{target_pos}.")

            if target_pos is not None or nxt.get("Type") == "маг":
                self._attack(nxt, target_pos)
                self._check_victory_after_hit()
                if self.winner is not None:
                    return False
        return False

    # ------------------ Наблюдение для агента ------------------

    def _obs(self) -> np.ndarray:
        """
        Построить наблюдение (120,):
          [HP, INI, INI_base, DMG, team(0/1), pos, stand(0/1), Archer, маг, Воин] × 12
        """
        vec = []
        type_to_onehot = {
            "Archer": (1.0, 0.0, 0.0),
            "маг":    (0.0, 1.0, 0.0),
            "Воин":   (0.0, 0.0, 1.0),
        }
        for pos in RED_POSITIONS + BLUE_POSITIONS:
            u = self._unit_by_position(pos)
            hp      = float(max(0, u["Здоровье"]))
            ini     = float(max(0, u["инициатива"]))
            ini_b   = float(u["инициатива_база"])
            dmg     = float(u["Урон"])
            team_v  = 0.0 if u["team"] == "red" else 1.0
            pos_v   = float(u["position"])
            stand_v = 0.0 if u["stand"] == "ahead" else 1.0
            oh      = type_to_onehot.get(u.get("Type", "Archer"), (1.0, 0.0, 0.0))
            vec.extend([hp, ini, ini_b, dmg, team_v, pos_v, stand_v, *oh])
        return np.array(vec, dtype=np.float32)

    # ------------------ API Gymnasium ------------------

    def reset(self, *, seed=None, options=None):
        if seed is not None:
            self.seed(seed)
        self._reset_state()
        self._advance_until_blue_turn()
        return self._obs(), {}

    def step(self, action):
        assert self.winner is None, "Эпизод завершён — вызовите reset()."

        # Докрутка до BLUE, если внезапно не его очередь
        if self.current_blue_attacker_pos is None:
            self._advance_until_blue_turn()
            if self.winner is not None:
                return self._obs(), (self.reward_win if self.winner == "blue" else self.reward_loss), True, False, {}

        # Ход BLUE
        target_pos = RED_POSITIONS[int(action)]
        attacker = self._unit_by_position(self.current_blue_attacker_pos)
        if attacker is not None and self._alive(attacker) and attacker["инициатива"] > 0:
            self._log(f"BLUE действие: {attacker['имя']}#{attacker['position']} → pos{target_pos}")
            attacker["инициатива"] = 0

            if attacker.get("Type") == "Воин":
                allowed = self._warrior_allowed_targets(attacker)
                if target_pos not in allowed:
                    self._log(f"BLUE {attacker['имя']}#{attacker['position']} (Воин) не может достать pos{target_pos}. "
                              f"Доступные цели: {(', '.join('pos'+str(p) for p in allowed)) if allowed else 'нет'}")
                else:
                    self._attack(attacker, target_pos)
                    self._check_victory_after_hit()
            else:
                self._attack(attacker, target_pos)
                self._check_victory_after_hit()

        # Если бой не завершился — двигаем ходы до следующего BLUE
        if self.winner is None:
            self.current_blue_attacker_pos = None
            self._advance_until_blue_turn()

        # Награда и флаги завершения
        if self.winner is None:
            reward, terminated = self.reward_step, False
        else:
            reward, terminated = (self.reward_win if self.winner == "blue" else self.reward_loss), True

        return self._obs(), reward, terminated, False, {}


# ============================================================
# БЛОК 2: ОБУЧЕНИЕ PPO + W&B, ТЕСТ И ОПЦИОНАЛЬНАЯ ВИЗУАЛИЗАЦИЯ
# ------------------------------------------------------------
# Требует, чтобы БЛОК 1 уже был выполнен (класс BattleEnv определён).
# ============================================================

# (Колаб) Установим нужные пакеты: SB3 и W&B. Gymnasium уже стоит.
!pip -q install "stable-baselines3[extra]" wandb

import os
import re
import time
import shutil
import random
import numpy as np
import torch

# Stable-Baselines3
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from stable_baselines3.common.callbacks import CallbackList, EvalCallback

# Weights & Biases
import wandb
from wandb.integration.sb3 import WandbCallback


# -------------------- Параметры обучения и теста --------------------
TOTAL_STEPS     = 100000
N_ENVS          = 8
MODEL_SAVE_FREQ = 1_000
EVAL_FREQ       = 1_000
SEED            = 42

VISUALIZE_TEST = True
FRAME_DELAY    = 0.28
USE_COLOR      = True

# -------------------- Инициализация W&B --------------------
# Перед первым запуском: wandb.login()
run = wandb.init(
    project="red-blue-battle",
    name=f"ppo-{TOTAL_STEPS//1000}k",
    config={
        "algo": "PPO",
        "total_timesteps": TOTAL_STEPS,
        "n_envs": N_ENVS,
        "n_steps": 1024,
        "batch_size": 2048,
        "gamma": 0.99,
        "gae_lambda": 0.95,
        "learning_rate": 3e-4,
        "clip_range": 0.2,
        "model_save_freq": MODEL_SAVE_FREQ,
        "eval_freq": EVAL_FREQ,
    },
    sync_tensorboard=True,
    save_code=True,
)

# -------------------- Фабрика сред --------------------
def make_env():
    return Monitor(BattleEnv(reward_win=1.0, reward_loss=-1.0, reward_step=0.0, log_enabled=False))

vec_env  = make_vec_env(make_env, n_envs=N_ENVS, seed=SEED)
eval_env = Monitor(BattleEnv(log_enabled=False))

# -------------------- Настройка модели PPO --------------------
model = PPO(
    policy="MlpPolicy",
    env=vec_env,
    verbose=1,
    n_steps=1024,
    batch_size=2048,
    gae_lambda=0.95,
    gamma=0.99,
    n_epochs=10,
    learning_rate=3e-4,
    clip_range=0.2,
    ent_coef=0.0,
    vf_coef=0.5,
    seed=SEED,
    tensorboard_log=f"./tb_logs/{run.id}",
)

# -------------------- Колбэки W&B и оценки --------------------
wandb_cb = WandbCallback(
    gradient_save_freq=1000,
    model_save_path=f"./models/{run.id}",
    model_save_freq=MODEL_SAVE_FREQ,
    verbose=2,
)
eval_cb = EvalCallback(
    eval_env,
    best_model_save_path=f"./models/{run.id}/best",
    log_path=f"./eval/{run.id}",
    eval_freq=EVAL_FREQ,
    n_eval_episodes=5,
    deterministic=True,
    render=False,
)

# -------------------- Обучение --------------------
model.learn(total_timesteps=TOTAL_STEPS, callback=CallbackList([wandb_cb, eval_cb]))

# Сохранить финальную модель
model.save("ppo_blue_vs_red")
run.finish()

# -------------------- Тестовый прогон с логами --------------------
print("\n=== ТЕСТОВЫЙ ПРОГОН С ЛОГАМИ ===")
test_env = BattleEnv(log_enabled=True)
obs, info = test_env.reset(seed=SEED + 123)

all_logs = []
all_logs += test_env.pop_pretty_events()

done = False
total_reward = 0.0
step_i = 0
while not done:
    step_i += 1
    action, _ = model.predict(obs, deterministic=True)
    target_pos = RED_POSITIONS[int(action)]
    chosen_line = f"[STEP {step_i}] Агент выбирает action={int(action)} → атака RED pos{target_pos}"
    print("\n" + chosen_line)
    all_logs.append(chosen_line)

    obs, reward, terminated, truncated, info = test_env.step(action)
    total_reward += reward
    done = terminated or truncated

    new_lines = test_env.pop_pretty_events()
    all_logs += new_lines
    for line in new_lines:
        print(line)

print("\n=== ЭПИЗОД ЗАВЕРШЁН ===")
print("Победитель:", test_env.winner.upper(), "| Суммарная награда:", total_reward)

# -------------------- Matplotlib-визуализация (12 юнитов, 8× медленнее, без мерцания, подсветки + баннеры + стрелки) --------------------
if VISUALIZE_TEST:
    import matplotlib.pyplot as plt
    from matplotlib import patches
    from IPython.display import display
    import re, time, math

    VISUAL_SPEED_MULT = 8.0  # было 4×, по просьбе замедлил ещё в 2×

    RED_FRONT, RED_BACK   = [1,2,3],   [4,5,6]
    BLUE_FRONT, BLUE_BACK = [7,8,9],   [10,11,12]
    COL_X = {0: 0.18, 1: 0.50, 2: 0.82}
    Y_BLUE_BACK, Y_BLUE_FRONT = 0.88, 0.70
    Y_RED_FRONT,  Y_RED_BACK  = 0.30, 0.12
    SLOT_W, SLOT_H = 0.28, 0.13
    HP_H = 0.025

    # состояние для отрисовки
    state = {pos: {"team": ("red" if pos in RED_POSITIONS else "blue"),
                   "name": f"pos{pos}", "hp": MAX_HP,
                   "stand": "ahead" if (pos in [1,2,3,7,8,9]) else "behind",
                   "type": "Archer"} for pos in (RED_POSITIONS + BLUE_POSITIONS)}
    for u in (UNITS_RED + UNITS_BLUE):
        suffix = " (маг)" if u.get("Type") == "маг" else (" (воин)" if u.get("Type") == "Воин" else "")
        state[u["position"]]["name"]  = u["имя"] + suffix
        state[u["position"]]["stand"] = u["stand"]
        state[u["position"]]["type"]  = u.get("Type", "Archer")

    # регексы
    atk_re   = re.compile(r'^(RED|BLUE)\s+[^\s#]+#(\d+)\s+→\s+(RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)→(\d+)\)')
    kill_re  = re.compile(r'^✖\s+(RED|BLUE)\s+[^\s#]+#(\d+)\s+выведен из строя\.')
    vict_re  = re.compile(r'^🏆 Победа (RED|BLUE)!')
    blue_turn_re    = re.compile(r'^Ход BLUE:\s+[^\s#]+#(\d+)')
    red_turn_re     = re.compile(r'^RED ход:\s+[^\s#]+#(\d+)')
    blue_action_re  = re.compile(r'^BLUE действие:\s+[^\s#]+#(\d+)\s+→\s+pos(\d+)')
    red_target_re   = re.compile(r'^RED ход:\s+[^\s#]+#(\d+).+цель pos(\d+)')
    mage_banner_re  = re.compile(r'^\w+\s+[^\s#]+#(\d+)\s+\(маг\).+массов')  # AOE объявление
    blue_cant_re    = re.compile(r'^BLUE\s+[^\s#]+#(\d+).+не может достать pos(\d+)')

    # фигура (без мерцания)
    fig, ax = plt.subplots(figsize=(12, 8))
    plt.close(fig)
    handle = display(fig, display_id=True)

    # -------- утилиты --------
    def pos_to_xy(pos: int):
        col = (pos - 1) % 3
        x = COL_X[col] - SLOT_W/2
        if pos in BLUE_BACK:   y = Y_BLUE_BACK  - SLOT_H/2
        elif pos in BLUE_FRONT:y = Y_BLUE_FRONT - SLOT_H/2
        elif pos in RED_FRONT: y = Y_RED_FRONT  - SLOT_H/2
        else:                  y = Y_RED_BACK   - SLOT_H/2
        return x, y

    def center_of(pos: int):
        x, y = pos_to_xy(pos)
        return (x + SLOT_W/2, y + SLOT_H/2)

    def shrink_segment(x1,y1,x2,y2, shrink=0.06):
        """Сдвигаем начало/конец внутрь, чтобы стрелка не перекрывала рамки слотов."""
        dx, dy = x2-x1, y2-y1
        L = math.hypot(dx, dy) or 1e-6
        ux, uy = dx/L, dy/L
        return (x1 + ux*shrink, y1 + uy*shrink, x2 - ux*shrink, y2 - uy*shrink)

    def _base_name(name: str) -> str:
        for suf in (" (маг)"," (воин)"):
            if name.endswith(suf):
                return name[:-len(suf)]
        return name

    def _type_label(t: str) -> str:
        return {"маг": "маг", "Воин": "Воин", "Archer": "Лучник"}.get(t, t)

    def draw_unit(ax, pos, is_active=False, is_hit=False):
        u = state[pos]; x, y = pos_to_xy(pos)
        base = (0.90, 0.30, 0.30) if u["team"] == "red" else (0.30, 0.45, 0.90)
        ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                            boxstyle="round,pad=0.008,rounding_size=0.015",
                                            linewidth=1.3, edgecolor="black", facecolor=base, alpha=0.18))
        if is_hit:
            ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=2.0, edgecolor=(0.75,0.05,0.05),
                                                facecolor=(1.0,0.0,0.0,0.15)))
        ax.text(x + 0.012, y + SLOT_H*0.72, u["name"][:18],
                fontsize=10, fontweight="bold", ha="left", va="center", color="black")
        t = u.get("type", "Archer"); t_icon = "A" if t=="Archer" else ("M" if t=="маг" else "W")
        ax.text(x + SLOT_W - 0.012, y + SLOT_H*0.72, t_icon,
                fontsize=11, fontweight="bold", ha="right", va="center", color="black")
        hp_x, hp_y = x + 0.012, y + SLOT_H*0.20
        ax.add_patch(patches.Rectangle((hp_x, hp_y), SLOT_W-0.024, HP_H, color=(0.85,0.85,0.85), lw=0))
        frac = max(0.0, min(1.0, u["hp"]/MAX_HP))
        ax.add_patch(patches.Rectangle((hp_x, hp_y), (SLOT_W-0.024)*frac, HP_H, color=(0.10,0.70,0.20), lw=0))
        ax.text(x + SLOT_W/2, hp_y + HP_H*2.2, f"{int(u['hp'])} HP", fontsize=9, ha="center", va="center", color="black")
        ax.text(x + SLOT_W/2, y - 0.008, f"pos{pos}", fontsize=8, ha="center", va="top", color=(0.2,0.2,0.2))
        if is_active:
            ax.add_patch(patches.FancyBboxPatch((x-0.004, y-0.004), SLOT_W+0.008, SLOT_H+0.008,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=3.0, edgecolor=(1.0,0.85,0.10), facecolor=(1,1,0,0.05)))

    def draw_arrows(ax, arrows):
        """arrows: список словарей {src:int, dst:int, color, lw, ls, alpha}"""
        for a in arrows or []:
            x1, y1 = center_of(a["src"])
            x2, y2 = center_of(a["dst"])
            x1, y1, x2, y2 = shrink_segment(x1, y1, x2, y2, shrink=0.06)
            ax.annotate("",
                        xy=(x2, y2), xytext=(x1, y1),
                        arrowprops=dict(arrowstyle="->",
                                        lw=a.get("lw", 2.0),
                                        color=a.get("color", (0.9,0.2,0.2)),
                                        linestyle=a.get("ls", "-"),
                                        alpha=a.get("alpha", 0.95)),
                        zorder=5)

    def draw_board(banner:str="", highlight_yellow=None, highlight_red=None, arrows=None):
        hy = set(highlight_yellow or []); hr = set(highlight_red or [])
        ax.cla()
        ax.set_xlim(0, 1); ax.set_ylim(0, 1); ax.axis("off")
        ax.plot([0.02, 0.98], [0.50, 0.50], color=(0.6,0.6,0.6), lw=1.2, ls="--", alpha=0.7)
        ax.text(0.01, 0.96, "BLUE (top)", color=(0.2,0.35,0.8), fontsize=12, fontweight="bold", ha="left")
        ax.text(0.01, 0.04, "RED (bottom)", color=(0.8,0.25,0.25), fontsize=12, fontweight="bold", ha="left")
        for pos in BLUE_BACK + BLUE_FRONT + RED_FRONT + RED_BACK:
            draw_unit(ax, pos, is_active=(pos in hy), is_hit=(pos in hr))
        draw_arrows(ax, arrows)
        if banner:
            ax.text(0.5, 0.52, banner[:120], fontsize=12, ha="center", va="bottom", color=(0.15,0.15,0.15))
        fig.canvas.draw()
        handle.update(fig)

    def attack_banner(atk_pos:int, vic_pos:int) -> str:
        a = state[atk_pos]; v = state[vic_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} атаковал юнита "{_base_name(v["name"])}" '
                f'на позиции {vic_pos}')

    def turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} готовится к ходу')

    def action_banner(atk_pos:int, tgt_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} готовится атаковать позицию {tgt_pos}')

    def mage_turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "маг" '
                f'с позиции {atk_pos} готовится применить массовую атаку')

    # первый кадр
    draw_board("Начало боя")

    # цикл анимации
    for line in all_logs:
        hy, hr = set(), set()
        arrows = []

        # Урон (одна цель) — красная стрелка
        m = atk_re.match(line)
        if m:
            atk_pos = int(m.group(2)); vic_pos = int(m.group(4)); after = int(m.group(7))
            if vic_pos in state: state[vic_pos]["hp"] = after
            hy.add(atk_pos); hr.add(vic_pos)
            arrows.append({"src": atk_pos, "dst": vic_pos, "color": (0.9,0.15,0.15), "lw": 2.6, "ls": "-", "alpha": 0.95})
            draw_board(attack_banner(atk_pos, vic_pos), hy, hr, arrows)
            time.sleep(FRAME_DELAY * VISUAL_SPEED_MULT)
            continue

        # Объявления хода
        m = blue_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Агент выбрал цель — жёлтая пунктирная стрелка к позиции
        m = blue_action_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_target_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Массовая атака мага — пунктир к каждому живому врагу
        m = mage_banner_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            enemy_team = "blue" if state[atk_pos]["team"] == "red" else "red"
            enemy_positions = [p for p,v in state.items() if v["team"] == enemy_team and v["hp"] > 0]
            for ep in enemy_positions:
                arrows.append({"src": atk_pos, "dst": ep, "color": (1.0,0.85,0.10), "lw": 1.6, "ls": "--", "alpha": 0.9})
            draw_board(mage_turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Цель недоступна — тоже жёлтая пунктирная
        m = blue_cant_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.8})
            draw_board(action_banner(atk_pos, tgt_pos) + " (цель недоступна)", hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Прочие строки (килл/победа/границы/STEP)
        if (kill_re.match(line) or vict_re.match(line)
            or line.startswith("— ") or line.startswith("[STEP")):
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # Фоллбек
        draw_board(line, hy, hr, arrows)
        time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)

    draw_board("Конец эпизода")
    time.sleep(0.8 * VISUAL_SPEED_MULT)
