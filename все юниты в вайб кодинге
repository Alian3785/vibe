# ============================================================
# БЛОК 1: КАСТОМНАЯ СРЕДА Gymnasium «RED vs BLUE»
# ------------------------------------------------------------
# Типы:
#  • Archer — одиночная атака (урон 20, HP 60)
#  • Death  — одиночная атака (урон 20, HP 60) + при ПЕРВОМ попадании накладывает яд:
#             цель получает 10 урона в НАЧАЛЕ своего хода 3 раза
#             + имеет иммунитет к типу атаки "Weapon" (см. свойство "иммунитет")
#  • Mage   — массовая атака по всем живым врагам (урон 10, HP 70)
#  • Воин   — ближний бой со смежностью (урон 30, HP 80)
#  • Demon  — как Воин по досягаемости, но бьёт ДВАЖДЫ подряд в свой ход (урон 30, HP 80)
#  • lord   — как Воин по досягаемости (1 удар). Первая ЕГО успешная атака накладывает «поджог»:
#             цель получает 10 урона в НАЧАЛЕ своего хода 3 раза.
#
# Новые свойства:
#  • "иммунитет": list[str] — список иммунитетов к типам атаки (напр., "Weapon", "earth", "Fire", ...)
#  • "Тип атаки 1": str     — базовый тип атаки юнита (сверяется с иммунитетом цели)
#  • "Тип атаки 2": str     — дополнительный тип атаки (обычно пусто; у Владыки: "Fire")
#     Правило иммунитета: если ЛЮБОЙ из типов атаки атакующего входит в список "иммунитет" цели,
#                         то цель получает 0 урона, и эффекты «при попадании» НЕ накладываются.
# ------------------------------------------------------------
# Примечание: ячейка не требует Stable-Baselines3 и Weights & Biases.
# ============================================================

# (Колаб) Мягко убедимся, что Gymnasium установлен.
try:
    import gymnasium as gym
except Exception:
    !pip -q install gymnasium
    import gymnasium as gym

import random
from operator import itemgetter
from typing import List, Dict, Optional

import numpy as np
from gymnasium import spaces

# ------------------------ Исходные юниты ------------------------
# Состав: спереди 2 воина + 1 демон; сзади 1 Death + 2 лучника. Аналогично у BLUE.
# Всем ставим "Тип атаки 1" == "Weapon", КРОМЕ одного лучника — у него "earth".
# Иммунитеты пустые везде, кроме Death: ["Weapon"].
# В СИНЕЙ команде один из воинов переименован в «Владыка», Type="lord",
# ему установлен "Тип атаки 2"="Fire" и эффект поджога на первую успешную атаку.

UNITS_RED = [
    {"имя": "рыцарь1",  "инициатива": 67, "инициатиива_база": 67, "team": "red", "position": 1, "stand": "ahead",
     "Type": "Воин", "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    {"имя": "рыцарь2",  "инициатива": 33, "инициатиива_база": 33, "team": "red", "position": 2, "stand": "ahead",
     "Type": "Воин", "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    {"имя": "демон1",    "инициатива": 78, "инициатиива_база": 78, "team": "red", "position": 3, "stand": "ahead",
     "Type": "Demon", "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    {"имя": "Смерть1",  "инициатива": 45, "инициатива_база": 45, "team": "red", "position": 4, "stand": "behind",
     "Type": "Death", "Урон": 20, "Здоровье": 60, "иммунитет": ["Weapon"], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    # Этот лучник — единственный с типом атаки earth
    {"имя": "Лучник",  "инициатива": 90, "инициатива_база": 90, "team": "red", "position": 5, "stand": "behind",
     "Type": "Archer","Урон": 20, "Здоровье": 60, "иммунитет": [], "Тип атаки 1": "earth", "Тип атаки 2": ""},
    {"имя": "Лучник2",  "инициатива": 12, "инициатива_база": 12, "team": "red", "position": 6, "stand": "behind",
     "Type": "Archer","Урон": 20, "Здоровье": 60, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
]
# Нормализация опечаток ключа базовой инициативы у RED
for u in UNITS_RED:
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")

UNITS_BLUE = [
    {"имя": "демон2",    "инициатива": 88, "инициатива_база": 88, "team": "blue","position": 7,  "stand": "ahead",
     "Type": "Demon", "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    # <<— этого воина заменили на Владыку (lord) с «Тип атаки 2» = Fire >>
    {"имя": "Владыка",  "инициатива": 55, "инициатиива_база": 55, "team": "blue","position": 8,  "stand": "ahead",
     "Type": "lord",  "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": "Fire"},
    {"имя": "рыцарь6",  "инициатива": 22, "инициатива_база": 22, "team": "blue","position": 9,  "stand": "ahead",
     "Type": "Воин",  "Урон": 30, "Здоровье": 80, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
    {"имя": "Лучник", "инициатива": 60, "инициатива_база": 60, "team": "blue","position": 10, "stand": "behind",
     "Type": "Archer","Урон": 20, "Здоровье": 60, "иммунитет": [], "Тип атаки 1": "earth", "Тип атаки 2": ""},
    # ЗАМЕНА: вместо Death используем лучника с типом атаки earth
    {"имя": "Смерть2",  "инициатива": 47, "инициатива_база": 47, "team": "blue","position": 11, "stand": "behind",
     "Type": "Archer","Урон": 20, "Здоровье": 60, "иммунитет": [], "Тип атаки 1": "earth", "Тип атаки 2": ""},
    {"имя": "Лучник2", "инициатива": 75, "инициатива_база": 75, "team": "blue","position": 12, "stand": "behind",
     "Type": "Archer","Урон": 20, "Здоровье": 60, "иммунитет": [], "Тип атаки 1": "Weapon", "Тип атаки 2": ""},
]
# Нормализация опечаток ключа у BLUE
for u in UNITS_BLUE:
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")
    if "инициатива_база" not in u and "инициатиива_база" in u:
        u["инициатива_база"] = u.pop("инициатиива_база")

# Диапазоны позиций
RED_POSITIONS:  List[int] = list(range(1, 7))
BLUE_POSITIONS: List[int] = list(range(7, 13))

# Максимумы HP по типам — для корректной визуализации реальных шкал HP
HP_MAX_BY_TYPE = {
    "Archer": 60,
    "Death": 60,
    "Mage": 70,
    "Воин": 80,
    "Demon": 80,
    "lord": 80,
}

# Константы для нормирования наблюдений
MAX_HP   = max([u["Здоровье"] for u in (UNITS_RED + UNITS_BLUE)])   # 80
MAX_INIT = max([u["инициатива_база"] for u in (UNITS_RED + UNITS_BLUE)])
MAX_DMG  = max([u["Урон"] for u in (UNITS_RED + UNITS_BLUE)])

POISON_DAMAGE = 10
POISON_TURNS  = 3

BURN_DAMAGE = 10
BURN_TURNS  = 3

# ------------------------ Кастомная среда ------------------------
class BattleEnv(gym.Env):
    """
    Среда RED vs BLUE для RL.

    Наблюдение (obs): вектор (120,) = 12 юнитов × 10 признаков:
       [HP, INI, INI_base, DMG, team, pos, stand, Archer, Mage, Воин] × 12.
       Примечание: Death кодируется как Archer в one-hot, Demon/lord — как Воин (чтобы не менять размерность).

    Действие (action): Discrete(6) — выбрать цель среди RED позиций 1..6.

    Типы атаки:
      • Archer — одиночная по цели.
      • Death  — одиночная + накладывает яд при первом попадании по юниту (10 урона × 3 в начале его хода).
      • Mage   — AoE по всем живым врагам.
      • Воин   — ближний бой со смежностью (см. правила).
      • Demon  — как Воин по досягаемости, но бьёт дважды подряд.
      • lord   — как Воин по досягаемости, 1 удар; первая успешная атака накладывает «поджог» (10×3 на старте хода цели).
    Иммунитеты:
      • Если ЛЮБОЙ тип атаки атакующего ("Тип атаки 1" ИЛИ "Тип атаки 2") входит в "иммунитет" цели → урон 0 и on-hit эффекты не применяются.
    """

    metadata = {"render_modes": []}

    def __init__(self,
                 reward_win: float = 1.0,
                 reward_loss: float = -1.0,
                 reward_step: float = 0.0,
                 penalty_invalid_target: float = -0.10,       # удар по мёртвому/пустому слоту
                 penalty_unreachable_warrior: float = -0.20,  # воин/демон/лорд: цель недоступна по правилам
                 log_enabled: bool = False):
        super().__init__()
        self.reward_win  = float(reward_win)
        self.reward_loss = float(reward_loss)
        self.reward_step = float(reward_step)

        # Штрафы
        self.penalty_invalid_target = float(penalty_invalid_target)
        self.penalty_unreachable_warrior = float(penalty_unreachable_warrior)

        self.log_enabled = bool(log_enabled)
        self._pretty_events: List[str] = []

        # Пространство действий
        self.action_space = spaces.Discrete(6)

        # Пространство наблюдений
        low_unit  = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float32)
        high_unit = np.array([MAX_HP, MAX_INIT, MAX_INIT, MAX_DMG, 1, 12, 1, 1, 1, 1], dtype=np.float32)
        low  = np.tile(low_unit, 12)
        high = np.tile(high_unit, 12)
        self.observation_space = spaces.Box(low=low, high=high, dtype=np.float32)

        # Состояние боя
        self.rng = random.Random()
        self.combined: List[Dict] = []
        self.round_no: int = 1
        self.winner: Optional[str] = None
        self.current_blue_attacker_pos: Optional[int] = None
        self.blue_attacks_left: int = 0  # остаток ударов у текущего BLUE (демон = 2)
        self._lord_applied_burn: Dict[int, bool] = {}  # pos -> True после ПЕРВОЙ успешной атаки лорда

    # ------------------ Вспомогательные методы ------------------

    def seed(self, seed=None):
        self.rng = random.Random(seed)

    def _alive(self, u) -> bool:
        return u["Здоровье"] > 0

    def _team_alive(self, team: str) -> bool:
        return any(self._alive(u) and u["team"] == team for u in self.combined)

    def _unit_by_position(self, pos: int):
        return next((u for u in self.combined if u["position"] == pos), None)

    def _live_positions_of(self, team: str):
        return [u["position"] for u in self.combined if u["team"] == team and self._alive(u)]

    def _log(self, s: str):
        if self.log_enabled:
            self._pretty_events.append(s)

    def pop_pretty_events(self) -> List[str]:
        out = self._pretty_events[:]
        self._pretty_events.clear()
        return out

    def _col_of(self, pos: int) -> int:
        """Колонка 0/1/2 (лев/центр/прав) по номеру позиции."""
        return (pos - 1) % 3

    def _enemy_rows(self, team: str):
        """(ahead_positions, behind_positions) противника в порядке колонок 0..2."""
        if team == "red":
            return [7, 8, 9], [10, 11, 12]
        else:
            return [1, 2, 3], [4, 5, 6]

    def _warrior_near_far_cols(self, col: int):
        """Какие колонки смежные и дальняя для воина по его колонке."""
        if col == 0:   # левый
            return [0, 1], [2]
        if col == 1:   # центр
            return [0, 1, 2], []
        return [1, 2], [0]  # правый

    def _warrior_allowed_targets(self, attacker: Dict) -> List[int]:
        """
        Вернуть позиции, по которым Воин/Demon/lord МОЖЕТ ударить сейчас.
        - В тылу не атакует, пока жив любой союзный Воин/Demon/lord во фронте.
        - Во фронт врага сначала бьёт смежных; «дальний» доступен, когда оба смежных мертвы.
        - Если фронт врага выбит — правила применяются к тылу врага.
        """
        assert attacker.get("Type") in ("Воин", "Demon", "lord")
        # В тылу — ждём, пока фронтовые свои воины живы
        if attacker["stand"] == "behind":
            if any(self._alive(u) and u["team"] == attacker["team"]
                   and u.get("Type") in ("Воин", "Demon", "lord") and u["stand"] == "ahead"
                   for u in self.combined):
                return []

        ahead, behind = self._enemy_rows(attacker["team"])
        col = self._col_of(attacker["position"])
        near_cols, far_cols = self._warrior_near_far_cols(col)

        def alive(pos):
            uu = self._unit_by_position(pos)
            return uu is not None and self._alive(uu)

        # Сначала фронт
        near = [ahead[c] for c in near_cols if alive(ahead[c])]
        if near:
            return near
        far = [ahead[c] for c in far_cols if alive(ahead[c])]
        if far:
            return far

        # Если фронт выбит — тыл
        near2 = [behind[c] for c in near_cols if alive(behind[c])]
        if near2:
            return near2
        far2 = [behind[c] for c in far_cols if alive(behind[c])]
        return far2

    def _pick_warrior_target_for_red(self, attacker: Dict) -> Optional[int]:
        """RED-(Воин/Demon/lord) выбирает цель с минимальным HP из доступных; при равенстве — случайная."""
        options = self._warrior_allowed_targets(attacker)
        if not options:
            return None
        pairs = [(self._unit_by_position(p)["Здоровье"], p) for p in options]
        min_hp = min(h for h, _ in pairs)
        pool = [p for h, p in pairs if h == min_hp]
        return self.rng.choice(pool)

    # ----------- эффекты начала хода (яд/поджог) -----------
    def _apply_start_of_turn_effects(self, unit: Dict) -> bool:
        """Возвращает True, если юнит жив после применения эффектов."""
        # ЯД
        if unit.get("poison_turns_left", 0) > 0 and self._alive(unit):
            before = unit["Здоровье"]
            unit["Здоровье"] -= POISON_DAMAGE
            unit["poison_turns_left"] -= 1
            after = unit["Здоровье"]
            self._log(f"☠ Яд поражает {unit['team'].upper()} {unit['имя']}#{unit['position']}: "
                      f"{POISON_DAMAGE} ({before}→{max(0, after)}); осталось ходов: {unit['poison_turns_left']}")
            if unit["Здоровье"] <= 0:
                unit["инициатива"] = 0
                self._log(f"✖ {unit['team'].upper()} {unit['имя']}#{unit['position']} погибает от яда.")
                self._check_victory_after_hit()
                return False

        # ПОДЖОГ
        if unit.get("burn_turns_left", 0) > 0 and self._alive(unit):
            before = unit["Здоровье"]
            unit["Здоровье"] -= BURN_DAMAGE
            unit["burn_turns_left"] -= 1
            after = unit["Здоровье"]
            self._log(f"🔥 Поджог поражает {unit['team'].upper()} {unit['имя']}#{unit['position']}: "
                      f"{BURN_DAMAGE} ({before}→{max(0, after)}); осталось ходов: {unit['burn_turns_left']}")
            if unit["Здоровье"] <= 0:
                unit["инициатива"] = 0
                self._log(f"✖ {unit['team'].upper()} {unit['имя']}#{unit['position']} погибает от поджога.")
                self._check_victory_after_hit()
                return False

        return True

    # ------------------ Боевая логика ------------------

    def _reset_state(self):
        self.combined = [u.copy() for u in (UNITS_RED + UNITS_BLUE)]
        for u in self.combined:
            # починка ключей и инициализация
            if "инициатива_база" not in u and "инициатиива_база" in u:
                u["инициатива_база"] = u.pop("инициатиива_база")
            if "инициатива_база" not in u and "инициатиива_база" in u:
                u["инициатива_база"] = u.pop("инициатиива_база")
            u["инициатива"] = u["инициатива_база"]
            u["poison_turns_left"] = 0
            u["burn_turns_left"] = 0
        self.round_no = 1
        self.winner = None
        self.current_blue_attacker_pos = None
        self.blue_attacks_left = 0
        self._lord_applied_burn = {}
        self._log(f"Эпизод начат. Раунд {self.round_no}.")

    def _candidates(self):
        return [u for u in self.combined if self._alive(u) and u["инициатива"] > 0]

    def _pop_next(self):
        cand = self._candidates()
        if not cand:
            return None
        self.rng.shuffle(cand)
        cand.sort(key=itemgetter("инициатива"), reverse=True)
        return cand[0]

    def _end_round_restore(self):
        for u in self.combined:
            u["инициатива"] = u["инициатива_база"] if self._alive(u) else 0
        self._log("Восстановление инициативы. Новый раунд.")

    def _is_immune(self, attacker: Dict, victim: Dict) -> bool:
        atk1 = attacker.get("Тип атаки 1", "Weapon")
        atk2 = attacker.get("Тип атаки 2", "")
        ims = victim.get("иммунитет") or []
        return (atk1 in ims) or (atk2 and atk2 in ims)

    def _attack(self, attacker, target_pos: Optional[int]):
        """
        Выполнить урон.
        Возврат: (hit: bool, reason: str)
          reason ∈ {"ok","dead_or_absent","aoe","aoe_no_targets","immune"}
        Иммунитет: если тип атаки (1 или 2) в "иммунитет" цели — урон 0 и on-hit эффекты не применяются.
        """
        # AoE для Mage
        if attacker is not None and attacker.get("Type") == "Mage":
            enemy_team = "blue" if attacker["team"] == "red" else "red"
            targets = [u for u in self.combined if u["team"] == enemy_team and self._alive(u)]
            if targets:
                self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} (Mage) применяет массовую атаку.")
                for victim in targets:
                    if self._is_immune(attacker, victim):
                        self._log(f"🛡 Иммунитет {victim['team'].upper()} {victim['имя']}#{victim['position']}: урон 0.")
                        continue
                    before = victim["Здоровье"]
                    victim["Здоровье"] -= attacker["Урон"]
                    after = victim["Здоровье"]
                    self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} → "
                              f"{victim['team'].upper()} {victim['имя']}#{victim['position']}: {attacker['Урон']} "
                              f"({before}→{max(0, after)})")
                    if victim["Здоровье"] <= 0:
                        victim["инициатива"] = 0
                        self._log(f"✖ {victim['team'].upper()} {victim['имя']}#{victim['position']} выведен из строя.")
                return True, "aoe"
            else:
                self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} (Mage) применяет массовую атаку: целей нет.")
                return False, "aoe_no_targets"

        # Обычная одиночная атака (Archer/Воин/Demon/Death/lord)
        victim = self._unit_by_position(target_pos) if target_pos is not None else None
        if victim is not None and self._alive(victim):
            # иммунитет
            if self._is_immune(attacker, victim):
                self._log(f"🛡 Иммунитет {victim['team'].upper()} {victim['имя']}#{victim['position']}: "
                          f"атака {attacker['имя']}#{attacker['position']} наносит 0 урона.")
                return True, "immune"

            before = victim["Здоровье"]
            victim["Здоровье"] -= attacker["Урон"]
            after = victim["Здоровье"]
            self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} → "
                      f"{victim['team'].upper()} {victim['имя']}#{victim['position']}: {attacker['Урон']} "
                      f"({before}→{max(0, after)})")

            # Death: наложение яда при первом успешном попадании по ЭТОЙ цели (если выжила и не иммун)
            if attacker.get("Type") == "Death" and victim.get("poison_turns_left", 0) <= 0 and self._alive(victim):
                victim["poison_turns_left"] = POISON_TURNS
                self._log(f"☠ {attacker['team'].upper()} {attacker['имя']}#{attacker['position']} накладывает яд на "
                          f"{victim['team'].upper()} {victim['имя']}#{victim['position']} на {POISON_TURNS} хода.")

            # lord: первая ЕГО успешная атака накладывает поджог (любую цель, если цель жива)
            if attacker.get("Type") == "lord" and self._alive(victim):
                pos = attacker["position"]
                if not self._lord_applied_burn.get(pos, False):
                    victim["burn_turns_left"] = BURN_TURNS
                    self._lord_applied_burn[pos] = True
                    self._log(f"🔥 {attacker['team'].upper()} {attacker['имя']}#{pos} накладывает поджог на "
                              f"{victim['team'].upper()} {victim['имя']}#{victim['position']} на {BURN_TURNS} хода.")

            if victim["Здоровье"] <= 0:
                victim["инициатива"] = 0
                self._log(f"✖ {victim['team'].upper()} {victim['имя']}#{victim['position']} выведен из строя.")
            return True, "ok"
        else:
            self._log(f"{attacker['team'].upper()} {attacker['имя']}#{attacker['position']} бьёт pos{target_pos}: цели нет/мертва/недоступна.")
            return False, "dead_or_absent"

    def _check_victory_after_hit(self):
        if not self._team_alive("blue"):
            self.winner = "red";  self._log("🏆 Победа RED!")
        elif not self._team_alive("red"):
            self.winner = "blue"; self._log("🏆 Победа BLUE!")

    def _advance_until_blue_turn(self) -> bool:
        """
        Автопрокрутка до следующего хода BLUE или завершения боя.
        RED ходит сам: Archer/Death — случайно; Mage — AoE; Воин/Demon/lord — по смежности (Demon бьёт дважды).
        """
        while self._team_alive("red") and self._team_alive("blue"):
            nxt = self._pop_next()
            if nxt is None:
                self._log(f"— Конец раунда {self.round_no}.")
                self._end_round_restore()
                self.round_no += 1
                self._log(f"— Начало раунда {self.round_no}.")
                continue

            # Эффекты начала хода (яд/поджог). Если умер — пропускаем действие.
            if not self._apply_start_of_turn_effects(nxt):
                if self.winner is not None:
                    return False
                continue

            if nxt["team"] == "blue":
                self.current_blue_attacker_pos = nxt["position"]
                self.blue_attacks_left = 2 if (nxt.get("Type") == "Demon") else 1
                self._log(
                    f"Ход BLUE: {nxt['имя']}#{nxt['position']} (иниц {nxt['инициатива']}). "
                    + ("Ожидание действия (демон: 2 удара)." if self.blue_attacks_left == 2 else "Ожидание действия.")
                )
                return True

            # Ход RED (авто)
            nxt["инициатива"] = 0
            strikes = 2 if nxt.get("Type") == "Demon" else 1

            for hit_i in range(strikes):
                if self.winner is not None:
                    return False

                target_pos = None
                if nxt.get("Type") in ("Воин", "Demon", "lord"):
                    target_pos = self._pick_warrior_target_for_red(nxt)
                    prefix = "Demon" if nxt.get("Type") == "Demon" else ("lord" if nxt.get("Type") == "lord" else "Воин")
                    if target_pos is None:
                        self._log(f"RED ход: {nxt['имя']}#{nxt['position']} ({prefix}) не может атаковать: доступных целей нет.")
                    else:
                        self._log(f"RED ход: {nxt['имя']}#{nxt['position']} ({prefix}) → цель pos{target_pos} (удар {hit_i+1}/{strikes}).")
                elif nxt.get("Type") == "Mage":
                    if hit_i == 0:
                        self._log(f"RED ход: {nxt['имя']}#{nxt['position']} (Mage) выполняет массовую атаку.")
                    else:
                        break
                else:
                    # Archer / Death — случайная живая цель
                    live_blue_positions = self._live_positions_of("blue")
                    target_pos = self.rng.choice(live_blue_positions) if live_blue_positions else None
                    ut = nxt.get("Type")
                    self._log(f"RED ход: {nxt['имя']}#{nxt['position']} ({ut}) → случайная цель pos{target_pos} (удар {hit_i+1}/{strikes}).")

                if target_pos is not None or nxt.get("Type") == "Mage":
                    self._attack(nxt, target_pos)
                    self._check_victory_after_hit()
                    if self.winner is not None:
                        return False
        return False

    # ------------------ Наблюдение для агента ------------------

    def _obs(self) -> np.ndarray:
        """
        Построить наблюдение (120,):
          [HP, INI, INI_base, DMG, team(0/1), pos, stand(0/1), Archer, Mage, Воин] × 12
        Death → Archer, Demon/lord → Воин в one-hot.
        """
        vec = []
        type_to_onehot = {
            "Archer": (1.0, 0.0, 0.0),
            "Mage":   (0.0, 1.0, 0.0),
            "Воин":   (0.0, 0.0, 1.0),
        }
        for pos in RED_POSITIONS + BLUE_POSITIONS:
            u = self._unit_by_position(pos)
            hp      = float(max(0, u["Здоровье"]))
            ini     = float(max(0, u["инициатива"]))
            ini_b   = float(u["инициатива_база"])
            dmg     = float(u["Урон"])
            team_v  = 0.0 if u["team"] == "red" else 1.0
            pos_v   = float(u["position"])
            stand_v = 0.0 if u["stand"] == "ahead" else 1.0
            t       = u.get("Type", "Archer")
            key     = "Воин" if t in ("Demon", "lord") else ("Archer" if t == "Death" else t)
            oh      = type_to_onehot.get(key, (1.0, 0.0, 0.0))
            vec.extend([hp, ini, ini_b, dmg, team_v, pos_v, stand_v, *oh])
        return np.array(vec, dtype=np.float32)

    # ------------------ API Gymnasium ------------------

    def reset(self, *, seed=None, options=None):
        if seed is not None:
            self.seed(seed)
        self._reset_state()
        self._advance_until_blue_turn()
        return self._obs(), {}

    def step(self, action):
        assert self.winner is None, "Эпизод завершён — вызовите reset()."

        # Докрутка до BLUE, если внезапно не его очередь
        if self.current_blue_attacker_pos is None:
            self._advance_until_blue_turn()
            if self.winner is not None:
                base = self.reward_win if self.winner == "blue" else self.reward_loss
                return self._obs(), base, True, False, {}

        # НАКОПИТЕЛЬ ШТРАФОВ ЗА ДЕЙСТВИЕ
        step_shaping = 0.0

        # Ход BLUE (возможно, это 1-й или 2-й удар демона)
        target_pos = RED_POSITIONS[int(action)]
        attacker = self._unit_by_position(self.current_blue_attacker_pos)
        if attacker is not None and self._alive(attacker) and attacker["инициатива"] > 0:
            self._log(f"BLUE действие: {attacker['имя']}#{attacker['position']} → pos{target_pos}")
            # Сбрасываем инициативу на первом ударе; второй удар демона выполнится без возврата хода
            attacker["инициатива"] = 0

            if attacker.get("Type") in ("Воин", "Demon", "lord"):
                allowed = self._warrior_allowed_targets(attacker)
                if target_pos not in allowed:
                    # Штраф: воин/демон/лорд пытается ударить недоступную цель
                    self._log(
                        f"BLUE {attacker['имя']}#{attacker['position']} ({attacker.get('Type')}) не может достать pos{target_pos}. "
                        f"Доступные цели: {(', '.join('pos'+str(p) for p in allowed)) if allowed else 'нет'}"
                    )
                    step_shaping += self.penalty_unreachable_warrior
                else:
                    hit, reason = self._attack(attacker, target_pos)
                    if not hit and reason == "dead_or_absent":
                        step_shaping += self.penalty_invalid_target
                    self._check_victory_after_hit()
            elif attacker.get("Type") == "Mage":
                hit, reason = self._attack(attacker, target_pos)
                self._check_victory_after_hit()
            else:
                # Archer / Death
                hit, reason = self._attack(attacker, target_pos)
                if not hit and reason == "dead_or_absent":
                    step_shaping += self.penalty_invalid_target
                self._check_victory_after_hit()

        # Если бой не завершился — проверяем, остались ли удары у BLUE (для демона)
        if self.winner is None:
            if self.blue_attacks_left > 0:
                self.blue_attacks_left -= 1
            # Если у демона остался ещё один удар — НЕ передаём ход и ждём следующего action
            if self.blue_attacks_left > 0:
                reward, terminated = self.reward_step + step_shaping, False
                return self._obs(), reward, terminated, False, {}
            # Иначе — передаём ход дальше
            self.current_blue_attacker_pos = None
            self._advance_until_blue_turn()

        # Награда и флаги завершения (добавляем shaping)
        if self.winner is None:
            base = self.reward_step
            terminated = False
        else:
            base = self.reward_win if self.winner == "blue" else self.reward_loss
            terminated = True

        reward = base + step_shaping
        return self._obs(), reward, terminated, False, {}

# ============================================================
# БЛОК 2: ОБУЧЕНИЕ PPO + W&B, ТЕСТ И ОПЦИОНАЛЬНАЯ ВИЗУАЛИЗАЦИЯ
# ------------------------------------------------------------
# Требует, чтобы БЛОК 1 уже был выполнен (класс BattleEnv определён).
# ============================================================

# (Колаб) Установим нужные пакеты: SB3 и W&B. Gymnasium уже стоит.
!pip -q install "stable-baselines3[extra]" wandb

import os
import re
import time
import shutil
import random
import numpy as np
import torch

# Stable-Baselines3
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from stable_baselines3.common.callbacks import CallbackList, EvalCallback

# Weights & Biases
import wandb
from wandb.integration.sb3 import WandbCallback

# -------------------- Параметры обучения и теста --------------------
TOTAL_STEPS     = 1_000_000
N_ENVS          = 8
MODEL_SAVE_FREQ = 1_000
EVAL_FREQ       = 1_000
SEED            = 42

VISUALIZE_TEST = True
FRAME_DELAY    = 0.28

# -------------------- Инициализация W&B --------------------
# Перед первым запуском: wandb.login()
run = wandb.init(
    project="red-blue-battle",
    name=f"ppo-{TOTAL_STEPS//1000}k-mixed-immune-lord",
    config={
        "algo": "PPO",
        "total_timesteps": TOTAL_STEPS,
        "n_envs": N_ENVS,
        "n_steps": 1024,
        "batch_size": 2048,
        "gamma": 0.99,
        "gae_lambda": 0.95,
        "learning_rate": 3e-4,
        "clip_range": 0.2,
        "model_save_freq": MODEL_SAVE_FREQ,
        "eval_freq": EVAL_FREQ,
    },
    sync_tensorboard=True,
    save_code=True,
)

# -------------------- Фабрика сред --------------------
def make_env():
    return Monitor(BattleEnv(
        reward_win=1.0, reward_loss=-1.0, reward_step=0.0,
        # penalty_invalid_target=-0.10,
        # penalty_unreachable_warrior=-0.20,
        log_enabled=False
    ))

vec_env  = make_vec_env(make_env, n_envs=N_ENVS, seed=SEED)
eval_env = Monitor(BattleEnv(log_enabled=False))

# -------------------- Настройка модели PPO --------------------
model = PPO(
    policy="MlpPolicy",
    env=vec_env,
    verbose=1,
    n_steps=1024,
    batch_size=2048,
    gae_lambda=0.95,
    gamma=0.99,
    n_epochs=10,
    learning_rate=3e-4,
    clip_range=0.2,
    ent_coef=0.0,
    vf_coef=0.5,
    seed=SEED,
    tensorboard_log=f"./tb_logs/{run.id}",
)

# -------------------- Колбэки W&B и оценки --------------------
wandb_cb = WandbCallback(
    gradient_save_freq=1000,
    model_save_path=f"./models/{run.id}",
    model_save_freq=MODEL_SAVE_FREQ,
    verbose=2,
)
eval_cb = EvalCallback(
    eval_env,
    best_model_save_path=f"./models/{run.id}/best",
    log_path=f"./eval/{run.id}",
    eval_freq=EVAL_FREQ,
    n_eval_episodes=5,
    deterministic=True,
    render=False,
)

# -------------------- Обучение --------------------
model.learn(total_timesteps=TOTAL_STEPS, callback=CallbackList([wandb_cb, eval_cb]))

# Сохранить финальную модель
model.save("ppo_blue_vs_red_mixed_immune_lord")
run.finish()

# -------------------- Тестовый прогон с логами --------------------
print("\n=== ТЕСТОВЫЙ ПРОГОН С ЛОГАМИ ===")
test_env = BattleEnv(log_enabled=True)
obs, info = test_env.reset(seed=SEED + 123)

all_logs = []
all_logs += test_env.pop_pretty_events()

done = False
total_reward = 0.0
step_i = 0
while not done:
    step_i += 1
    action, _ = model.predict(obs, deterministic=True)
    target_pos = RED_POSITIONS[int(action)]
    chosen_line = f"[STEP {step_i}] Агент выбирает action={int(action)} → атака RED pos{target_pos}"
    print("\n" + chosen_line)
    all_logs.append(chosen_line)

    obs, reward, terminated, truncated, info = test_env.step(action)
    total_reward += reward
    done = terminated or truncated

    new_lines = test_env.pop_pretty_events()
    all_logs += new_lines
    for line in new_lines:
        print(line)

print("\n=== ЭПИЗОД ЗАВЕРШЁН ===")
print("Победитель:", test_env.winner.upper(), "| Суммарная награда:", total_reward)

# -------------------- Matplotlib-визуализация (реальные шкалы HP + яд + демон + иммунитеты + лорд/поджог) --------------------
if VISUALIZE_TEST:
    import matplotlib.pyplot as plt
    from matplotlib import patches
    from IPython.display import display
    import re, time, math

    VISUAL_SPEED_MULT = 8.0

    RED_FRONT, RED_BACK   = [1,2,3],   [4,5,6]
    BLUE_FRONT, BLUE_BACK = [7,8,9],   [10,11,12]
    COL_X = {0: 0.18, 1: 0.50, 2: 0.82}
    Y_BLUE_BACK, Y_BLUE_FRONT = 0.88, 0.70
    Y_RED_FRONT,  Y_RED_BACK  = 0.30, 0.12
    SLOT_W, SLOT_H = 0.28, 0.13
    HP_H = 0.025

    # состояние для отрисовки — берём реальные стартовые HP из UNITS_* и их макс. HP по типу
    state = {}
    def _suffix_by_type(t: str) -> str:
        return {
            "Mage": " (Mage)",
            "Воин": " (воин)",
            "Demon": " (Demon)",
            "Death": " (Death)",
            "Archer": " (лучник)",
            "lord": " (Lord)",
        }.get(t, f" ({t})")

    for u in (UNITS_RED + UNITS_BLUE):
        t = u.get("Type", "Archer")
        state[u["position"]] = {
            "team": u["team"],
            "name": u["имя"] + _suffix_by_type(t),
            "hp": float(u["Здоровье"]),                    # текущие HP
            "maxhp": float(HP_MAX_BY_TYPE.get(t, 60)),     # персональный максимум для шкалы
            "stand": u["stand"],
            "type": t,
        }

    # регексы для парсинга логов
    atk_re   = re.compile(r'^(RED|BLUE)\s+[^\s#]+#(\d+)\s+→\s+(RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)→(\d+)\)')
    kill_re  = re.compile(r'^✖\s+(RED|BLUE)\s+[^\s#]+#(\d+)\s+выведен из строя\.')
    vict_re  = re.compile(r'^🏆 Победа (RED|BLUE)!')
    blue_turn_re    = re.compile(r'^Ход BLUE:\s+[^\s#]+#(\d+)')
    red_turn_re     = re.compile(r'^RED ход:\s+[^\s#]+#(\d+)')
    blue_action_re  = re.compile(r'^BLUE действие:\s+[^\s#]+#(\d+)\s+→\s+pos(\d+)')
    red_target_re   = re.compile(r'^RED ход:\s+[^\s#]+#(\d+).+цель pos(\d+)')
    mage_banner_re  = re.compile(r'^\w+\s+[^\s#]+#(\d+)\s+\(Mage\).+массов')
    blue_cant_re    = re.compile(r'^BLUE\s+[^\s#]+#(\d+).+не может достать pos(\d+)')
    poison_tick_re  = re.compile(r'^☠ Яд поражает (RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)→(\d+)\)')
    burn_tick_re    = re.compile(r'^🔥 Поджог поражает (RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)→(\д+)\)')
    # исправление опечатки в шаблоне burn (на случай локального запуска)
    burn_tick_re    = re.compile(r'^🔥 Поджог поражает (RED|BLUE)\s+[^\s#]+#(\d+):\s+(\d+)\s+\((\d+)→(\d+)\)')
    immune_log_re   = re.compile(r'^🛡 Иммунитет (RED|BLUE)\s+[^\s#]+#(\d+)')  # визуально подсветим цель

    # фигура (без мерцания)
    fig, ax = plt.subplots(figsize=(12, 8))
    plt.close(fig)
    handle = display(fig, display_id=True)

    # -------- утилиты --------
    def pos_to_xy(pos: int):
        col = (pos - 1) % 3
        x = COL_X[col] - SLOT_W/2
        if pos in BLUE_BACK:   y = Y_BLUE_BACK  - SLOT_H/2
        elif pos in BLUE_FRONT:y = Y_BLUE_FRONT - SLOT_H/2
        elif pos in RED_FRONT: y = Y_RED_FRONT  - SLOT_H/2
        else:                  y = Y_RED_BACK   - SLOT_H/2
        return x, y

    def center_of(pos: int):
        x, y = pos_to_xy(pos)
        return (x + SLOT_W/2, y + SLOT_H/2)

    def shrink_segment(x1,y1,x2,y2, shrink=0.06):
        dx, dy = x2-x1, y2-y1
        L = math.hypot(dx, dy) or 1e-6
        ux, uy = dx/L, dy/L
        return (x1 + ux*shrink, y1 + uy*shrink, x2 - ux*shrink, y2 - uy*shrink)

    def _base_name(name: str) -> str:
        for suf in (" (Mage)"," (воин)"," (Demon)"," (Death)"," (лучник)"," (Lord)"):
            if name.endswith(suf):
                return name[:-len(suf)]
        return name

    def _type_label(t: str) -> str:
        return {"Mage": "Mage", "Воин": "Воин", "Demon": "Воин-демон", "Death": "Death", "Archer": "Лучник", "lord": "Владыка"}.get(t, t)

    def draw_unit(ax, pos, is_active=False, is_hit=False):
        u = state[pos]; x, y = pos_to_xy(pos)
        base = (0.90, 0.30, 0.30) if u["team"] == "red" else (0.30, 0.45, 0.90)
        ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                            boxstyle="round,pad=0.008,rounding_size=0.015",
                                            linewidth=1.3, edgecolor="black", facecolor=base, alpha=0.18))
        if is_hit:
            ax.add_patch(patches.FancyBboxPatch((x, y), SLOT_W, SLOT_H,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=2.0, edgecolor=(0.75,0.05,0.05),
                                                facecolor=(1.0,0.0,0.0,0.15)))
        ax.text(x + 0.012, y + SLOT_H*0.72, u["name"][:18],
                fontsize=10, fontweight="bold", ha="left", va="center", color="black")
        t = u.get("type", "Archer")
        icon = "A" if t=="Archer" else ("M" if t=="Mage" else ("W²" if t=="Demon" else ("D" if t=="Death" else ("L" if t=="lord" else "W"))))
        ax.text(x + SLOT_W - 0.012, y + SLOT_H*0.72, icon,
                fontsize=11, fontweight="bold", ha="right", va="center", color="black")

        # HP-бар: НОРМАЛИЗУЕМ НА ПЕРСОНАЛЬНЫЙ МАКСИМУМ
        hp_x, hp_y = x + 0.012, y + SLOT_H*0.20
        ax.add_patch(patches.Rectangle((hp_x, hp_y), SLOT_W-0.024, HP_H, color=(0.85,0.85,0.85), lw=0))
        frac = 0.0
        if u["maxhp"] > 1e-9:
            frac = max(0.0, min(1.0, u["hp"]/u["maxhp"]))
        ax.add_patch(patches.Rectangle((hp_x, hp_y), (SLOT_W-0.024)*frac, HP_H, color=(0.10,0.70,0.20), lw=0))
        ax.text(x + SLOT_W/2, hp_y + HP_H*2.2, f"{int(max(0,u['hp']))}/{int(u['maxhp'])} HP",
                fontsize=9, ha="center", va="center", color="black")

        ax.text(x + SLOT_W/2, y - 0.008, f"pos{pos}", fontsize=8, ha="center", va="top", color=(0.2,0.2,0.2))
        if is_active:
            ax.add_patch(patches.FancyBboxPatch((x-0.004, y-0.004), SLOT_W+0.008, SLOT_H+0.008,
                                                boxstyle="round,pad=0.008,rounding_size=0.015",
                                                linewidth=3.0, edgecolor=(1.0,0.85,0.10), facecolor=(1,1,0,0.05)))

    def draw_arrows(ax, arrows):
        for a in arrows or []:
            x1, y1 = center_of(a["src"])
            x2, y2 = center_of(a["dst"])
            x1, y1, x2, y2 = shrink_segment(x1, y1, x2, y2, shrink=0.06)
            ax.annotate("",
                        xy=(x2, y2), xytext=(x1, y1),
                        arrowprops=dict(arrowstyle="->",
                                        lw=a.get("lw", 2.0),
                                        color=a.get("color", (0.9,0.2,0.2)),
                                        linestyle=a.get("ls", "-"),
                                        alpha=a.get("alpha", 0.95)),
                        zorder=5)

    def draw_board(banner:str="", highlight_yellow=None, highlight_red=None, arrows=None):
        hy = set(highlight_yellow or []); hr = set(highlight_red or [])
        ax.cla()
        ax.set_xlim(0, 1); ax.set_ylim(0, 1); ax.axis("off")
        ax.plot([0.02, 0.98], [0.50, 0.50], color=(0.6,0.6,0.6), lw=1.2, ls="--", alpha=0.7)
        ax.text(0.01, 0.96, "BLUE (top)", color=(0.2,0.35,0.8), fontsize=12, fontweight="bold", ha="left")
        ax.text(0.01, 0.04, "RED (bottom)", color=(0.8,0.25,0.25), fontsize=12, fontweight="bold", ha="left")
        for pos in BLUE_BACK + BLUE_FRONT + RED_FRONT + RED_BACK:
            draw_unit(ax, pos, is_active=(pos in hy), is_hit=(pos in hr))
        draw_arrows(ax, arrows)
        if banner:
            ax.text(0.5, 0.52, banner[:120], fontsize=12, ha="center", va="bottom", color=(0.15,0.15,0.15))
        fig.canvas.draw()
        handle.update(fig)

    def attack_banner(atk_pos:int, vic_pos:int) -> str:
        a = state[atk_pos]; v = state[vic_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} атаковал юнита "{_base_name(v["name"])}" '
                f'на позиции {vic_pos}')

    def turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} готовится к ходу')

    def action_banner(atk_pos:int, tgt_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "{_type_label(a["type"])}" '
                f'с позиции {atk_pos} готовится атаковать позицию {tgt_pos}')

    def mage_turn_banner(atk_pos:int) -> str:
        a = state[atk_pos]
        return (f'Юнит "{_base_name(a["name"])}" типа "Mage" '
                f'с позиции {atk_pos} готовится применить массовую атаку')

    # первый кадр
    draw_board("Начало боя")

    # цикл анимации
    for line in all_logs:
        hy, hr = set(), set()
        arrows = []

        # Урон (одна цель) — красная стрелка + обновление HP
        m = atk_re.match(line)
        if m:
            atk_pos = int(m.group(2)); vic_pos = int(m.group(4)); after = int(m.group(7))
            if vic_pos in state: state[vic_pos]["hp"] = after
            hy.add(atk_pos); hr.add(vic_pos)
            arrows.append({"src": atk_pos, "dst": vic_pos, "color": (0.9,0.15,0.15), "lw": 2.6, "ls": "-", "alpha": 0.95})
            draw_board(attack_banner(atk_pos, vic_pos), hy, hr, arrows)
            time.sleep(FRAME_DELAY * VISUAL_SPEED_MULT)
            continue

        # Иммунитет — просто подсветим цель
        m = immune_log_re.match(line)
        if m:
            # второй группой может быть позиция, но регулярка простая — всё равно подсветим
            tokens = re.findall(r'#(\d+)', line)
            if tokens:
                vic_pos = int(tokens[-1])
                hr.add(vic_pos)
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # Тик яда — обновляем HP по логу
        m = poison_tick_re.match(line)
        if m:
            vic_pos = int(m.group(2))
            after = int(m.group(5))
            if vic_pos in state: state[vic_pos]["hp"] = after
            hr.add(vic_pos)
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # Тик поджога — обновляем HP по логу
        m = burn_tick_re.match(line)
        if m:
            vic_pos = int(m.group(2))
            after = int(m.group(5))
            if vic_pos in state: state[vic_pos]["hp"] = after
            hr.add(vic_pos)
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # Объявления хода
        m = blue_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_turn_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            draw_board(turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Агент выбрал цель — жёлтая пунктирная стрелка к позиции
        m = blue_action_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        m = red_target_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.95})
            draw_board(action_banner(atk_pos, tgt_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Массовая атака Mage — пунктир к каждому живому врагу
        m = mage_banner_re.match(line)
        if m:
            atk_pos = int(m.group(1)); hy.add(atk_pos)
            enemy_team = "blue" if state[atk_pos]["team"] == "red" else "red"
            enemy_positions = [p for p,v in state.items() if v["team"] == enemy_team and v["hp"] > 0]
            for ep in enemy_positions:
                arrows.append({"src": atk_pos, "dst": ep, "color": (1.0,0.85,0.10), "lw": 1.6, "ls": "--", "alpha": 0.9})
            draw_board(mage_turn_banner(atk_pos), hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Цель недоступна — жёлтая пунктирная
        m = blue_cant_re.match(line)
        if m:
            atk_pos = int(m.group(1)); tgt_pos = int(m.group(2)); hy.add(atk_pos)
            arrows.append({"src": atk_pos, "dst": tgt_pos, "color": (1.0,0.85,0.10), "lw": 1.8, "ls": "--", "alpha": 0.8})
            draw_board(action_banner(atk_pos, tgt_pos) + " (цель недоступна)", hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2); continue

        # Прочие строки (килл/победа/границы/STEP)
        if (kill_re.match(line) or vict_re.match(line)
            or line.startswith("— ") or line.startswith("[STEP")):
            draw_board(line, hy, hr, arrows)
            time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)
            continue

        # Фоллбек
        draw_board(line, hy, hr, arrows)
        time.sleep((FRAME_DELAY * VISUAL_SPEED_MULT) / 1.2)

    draw_board("Конец эпизода")
    time.sleep(0.8 * VISUAL_SPEED_MULT)
